<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SkyBeast Ascension</title>
  <style>
    :root {
      --bg1: #05111f;
      --bg2: #132f49;
      --gold: #f4c542;
      --mint: #6df2c1;
      --panel: rgba(8, 17, 30, 0.78);
      --text: #eaf4ff;
      --muted: #9eb9d7;
      --ui-scale: 1;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      font-size: calc(16px * var(--ui-scale));
      color: var(--text);
      min-height: 100vh;
      background:
        radial-gradient(circle at 9% 18%, #285e85 0%, transparent 36%),
        radial-gradient(circle at 84% 7%, #2f4578 0%, transparent 33%),
        linear-gradient(126deg, var(--bg1), var(--bg2));
      overflow: hidden;
      padding: 0;
    }

    body.high-contrast {
      --bg1: #01040a;
      --bg2: #082042;
      --panel: rgba(0, 0, 0, 0.9);
      --text: #ffffff;
      --muted: #d8e7ff;
      --gold: #ffd357;
      --mint: #8dffd0;
    }

    body.high-contrast .panel {
      border-color: rgba(255, 255, 255, 0.34);
    }

    body.high-contrast button.secondary {
      border-color: rgba(255, 255, 255, 0.42);
      background: rgba(255, 255, 255, 0.16);
    }

    .app {
      width: 100vw;
      height: 100vh;
      position: relative;
      padding: 10px;
    }

    .app.prelaunch .overlay-toggle,
    .app.prelaunch .top-hud {
      display: none;
    }

    .app.in-game .top-hud {
      display: none;
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(198, 228, 255, 0.18);
      border-radius: 18px;
      backdrop-filter: blur(7px);
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }

    .left {
      position: absolute;
      top: 10px;
      left: 10px;
      width: min(330px, calc(100vw - 20px));
      max-height: calc(100vh - 20px);
      overflow: auto;
      z-index: 20;
      padding: 14px;
      display: grid;
      gap: 10px;
      align-content: start;
      background: linear-gradient(180deg, rgba(6, 16, 32, 0.92), rgba(5, 20, 41, 0.88));
    }

    .left.collapsed {
      display: none;
    }

    h1 {
      font-size: 1.4rem;
      line-height: 1.2;
      letter-spacing: 0.4px;
    }

    p {
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.4;
    }

    .badge {
      display: inline-block;
      background: rgba(244, 197, 66, 0.15);
      color: var(--gold);
      border: 1px solid rgba(244, 197, 66, 0.35);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.75rem;
    }

    .row {
      display: grid;
      gap: 7px;
    }

    label {
      font-size: 0.78rem;
      color: #cdddf0;
    }

    input, select {
      width: 100%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 10px;
      padding: 10px 12px;
      outline: none;
    }

    input:focus, select:focus {
      border-color: #6ec6ff;
      box-shadow: 0 0 0 3px rgba(110, 198, 255, 0.2);
    }

    .setting-row {
      display: grid;
      gap: 6px;
      margin-bottom: 6px;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.82rem;
      color: #d6e7f8;
    }

    .toggle-row input[type="checkbox"] {
      width: 18px;
      height: 18px;
      padding: 0;
      accent-color: #6ec6ff;
      cursor: pointer;
    }

    .settings-section {
      border: 1px solid rgba(184, 222, 255, 0.2);
      border-radius: 12px;
      padding: 10px;
      background: rgba(8, 22, 40, 0.45);
      display: grid;
      gap: 8px;
    }

    .settings-title {
      font-size: 0.96rem;
      color: #e9f5ff;
      letter-spacing: 0.25px;
    }

    .settings-desc {
      font-size: 0.78rem;
      color: #abc6de;
    }

    .settings-actions {
      display: grid;
      gap: 8px;
    }

    .settings-actions button {
      width: 100%;
    }

    .preset-row {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .preset-btn {
      padding: 8px 10px;
      font-size: 0.8rem;
      border-radius: 9px;
    }

    .preset-btn.active {
      border: 1px solid rgba(255, 255, 255, 0.34);
      background: linear-gradient(180deg, #37a3de, #166892);
      color: #f3fbff;
    }

    .settings-subtitle {
      font-size: 0.78rem;
      letter-spacing: 0.2px;
      color: #b5d8f5;
      font-weight: 700;
    }

    .label-help {
      display: inline-grid;
      place-items: center;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      color: #d8edff;
      font-size: 0.66rem;
      margin-left: 6px;
      cursor: help;
      user-select: none;
      background: rgba(255, 255, 255, 0.08);
      vertical-align: middle;
    }

    .settings-io {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .advanced-settings {
      border: 1px solid rgba(184, 222, 255, 0.2);
      border-radius: 10px;
      background: rgba(8, 22, 40, 0.35);
      overflow: hidden;
    }

    .advanced-settings summary {
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 700;
      color: #e7f4ff;
      padding: 10px;
      user-select: none;
    }

    .advanced-settings[open] summary {
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
    }

    .advanced-body {
      display: grid;
      gap: 8px;
      padding: 10px;
    }

    .slider-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      font-size: 0.8rem;
      color: #d7eaff;
    }

    .audio-disabled {
      opacity: 0.66;
      pointer-events: none;
    }

    .slider-row input[type="range"] {
      width: 100%;
      margin-top: 2px;
      accent-color: #6ec6ff;
    }

    input[type="range"] {
      padding: 0;
      border: none;
      background: transparent;
      box-shadow: none;
    }

    input[type="range"]:focus {
      border: none;
      box-shadow: none;
    }

    .bind-grid {
      display: grid;
      gap: 6px;
    }

    .bind-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      font-size: 0.8rem;
      color: #d6e7f8;
    }

    .bind-btn {
      min-width: 118px;
      font-size: 0.75rem;
      padding: 7px 8px;
      border-radius: 8px;
    }

    .bind-btn.listening {
      border: 1px solid rgba(255, 255, 255, 0.42);
      background: rgba(85, 165, 217, 0.28);
      color: #eff8ff;
    }

    button {
      cursor: pointer;
      border: none;
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: 700;
      color: #081422;
      background: linear-gradient(90deg, var(--mint), #8ad3ff);
    }

    button.secondary {
      color: var(--text);
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.22);
    }

    #googleRender {
      min-height: 40px;
      display: grid;
      align-items: center;
      justify-items: center;
    }

    .hidden-auth {
      display: none !important;
    }

    .profile-card {
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      padding: 10px;
      display: grid;
      gap: 6px;
    }

    .profile-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.82rem;
      color: #dbeeff;
      font-weight: 700;
    }

    .profile-meta {
      font-size: 0.78rem;
      color: var(--muted);
      line-height: 1.35;
      word-break: break-word;
    }

    .small {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .status {
      border-top: 1px solid rgba(255, 255, 255, 0.15);
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      padding: 10px 0;
      display: grid;
      gap: 6px;
    }

    .status div {
      font-size: 0.86rem;
      display: flex;
      justify-content: space-between;
    }

    .status .setting-row {
      display: grid;
      justify-content: stretch;
    }

    .bar {
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.13);
      overflow: hidden;
    }

    .bar > span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--gold), #ffd977);
    }

    .controls {
      font-size: 0.78rem;
      line-height: 1.45;
      color: #bdd2ec;
    }

    .game-wrap {
      position: absolute;
      inset: 10px;
      border-radius: 20px;
      overflow: hidden;
      border: 1px solid rgba(188, 224, 255, 0.2);
      box-shadow:
        0 25px 55px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    canvas {
      width: 100%;
      height: 100%;
      min-height: calc(100vh - 20px);
      display: block;
      background:
        linear-gradient(to top, #3a5936 0 24%, #5c874f 24% 28%, #88c7ee 28% 100%);
    }

    .toast {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.46);
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.25s ease;
      pointer-events: none;
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: min(92vw, 620px);
      z-index: 25;
    }

    .top-hud {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      width: min(1040px, calc(100% - 26px));
      z-index: 5;
      display: grid;
      gap: 8px;
      pointer-events: none;
    }

    .top-bar {
      display: grid;
      grid-template-columns: 1fr 220px;
      gap: 8px;
    }

    .top-pill, .play-btn, .guide-card {
      border: 1px solid rgba(190, 221, 246, 0.22);
      border-radius: 12px;
      background: rgba(10, 34, 52, 0.86);
      color: #ecf6ff;
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.35);
    }

    .top-pill, .play-btn {
      min-height: 52px;
      display: grid;
      place-items: center;
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .play-btn {
      background: linear-gradient(180deg, #3393d1, #136695);
      color: #eaf6ff;
      cursor: pointer;
      pointer-events: auto;
      min-width: 0;
    }

    .guide-card {
      padding: 10px 14px;
      line-height: 1.35;
      font-size: 0.9rem;
    }

    .guide-card b {
      color: #ffffff;
      font-size: 1rem;
      display: block;
      margin-bottom: 3px;
    }

    .overlay-toggle {
      position: absolute;
      left: 14px;
      bottom: 14px;
      z-index: 12;
      background: rgba(8, 18, 36, 0.86);
      color: #dff0ff;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 9px;
      padding: 8px 10px;
      font-size: 0.78rem;
      font-weight: 700;
    }

    .start-screen {
      position: absolute;
      inset: 0;
      z-index: 15;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 50% 14%, rgba(150, 219, 255, 0.21), rgba(106, 177, 235, 0) 48%),
        linear-gradient(180deg, rgba(5, 14, 28, 0.34), rgba(5, 10, 18, 0.74));
      backdrop-filter: blur(2px);
    }

    .start-screen.hidden {
      display: none;
    }

    .start-card {
      width: min(580px, calc(100vw - 30px));
      border-radius: 18px;
      border: 1px solid rgba(222, 242, 255, 0.35);
      background: linear-gradient(180deg, rgba(7, 26, 47, 0.95), rgba(5, 18, 32, 0.93));
      padding: 22px 22px;
      box-shadow: 0 28px 54px rgba(0, 0, 0, 0.44);
      text-align: center;
      display: grid;
      gap: 12px;
    }

    .start-card h2 {
      font-size: 1.5rem;
      letter-spacing: 0.35px;
    }

    .start-card p {
      color: #c4d8ee;
      font-size: 0.96rem;
    }

    .start-chip {
      justify-self: center;
      font-size: 0.78rem;
      padding: 5px 11px;
      border-radius: 999px;
      border: 1px solid rgba(118, 191, 247, 0.44);
      color: #afe2ff;
      background: rgba(48, 109, 152, 0.3);
    }

    .start-list {
      text-align: left;
      color: #b8d0e6;
      font-size: 0.88rem;
      line-height: 1.45;
      background: rgba(9, 29, 50, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 12px;
      padding: 10px 12px;
    }

    .start-card .start-btn {
      margin-top: 4px;
      font-size: 1.05rem;
      padding: 12px 16px;
      border-radius: 12px;
      background: linear-gradient(180deg, #37a3de, #166892);
      color: #f2fbff;
      border: 1px solid rgba(255, 255, 255, 0.28);
    }

    .toast.show {
      opacity: 1;
    }

    .toast.actionable {
      pointer-events: auto;
    }

    .toast .toast-action {
      border-radius: 8px;
      padding: 5px 8px;
      font-size: 0.78rem;
      border: 1px solid rgba(255, 255, 255, 0.34);
      background: rgba(255, 255, 255, 0.16);
      color: #eff7ff;
      font-weight: 700;
      cursor: pointer;
    }

    @media (max-width: 980px) {
      canvas {
        min-height: calc(100vh - 20px);
      }
      .top-hud {
        width: calc(100% - 20px);
      }
      .top-bar {
        grid-template-columns: 1fr;
      }
      .left {
        width: min(300px, calc(100vw - 24px));
      }
      .game-wrap {
        inset: 8px;
        border-radius: 14px;
      }
    }
  </style>
</head>
<body>
  <main class="app prelaunch" id="appRoot">
    <section class="panel left collapsed" id="controlPanel">
      <h1>SkyBeast Ascension</h1>
      <p>Start on land, unlock flight at tier 6, roam a huge world map, and evolve to the final Moon forms.</p>
      <span class="badge">30 Total Evolutions (27 Animals + Moon 3/2/1)</span>

      <div class="row">
        <label for="playerName">Player Name</label>
        <input id="playerName" placeholder="Enter name" />
      </div>
      <div class="row">
        <label for="playerEmail">Email</label>
        <input id="playerEmail" type="email" placeholder="Enter email" />
      </div>
      <button id="signupBtn">Sign Up (Free)</button>
      <button id="googleBtn" class="secondary">Sign In With Google</button>
      <div id="googleRender"></div>
      <button id="subBtn" class="secondary">Activate Subscription Boost (+60%)</button>
      <p id="accountState" class="small">Not signed in</p>
      <p class="small" id="googleHint">Google login loads from server config (`GOOGLE_CLIENT_ID`).</p>
      <p class="small" id="progressHint">Sign in to save long-term XP. Every new match starts at Tier 1.</p>
      <div id="profileCard" class="profile-card hidden-auth">
        <div class="profile-head">
          <span>Profile</span>
          <button id="logoutBtn" class="secondary" type="button">Log Out</button>
        </div>
        <p id="profileMeta" class="profile-meta">No active profile.</p>
      </div>

      <div class="status">
        <div><span>Current Form</span><strong id="formName">Ant</strong></div>
        <div><span>Tier</span><strong id="tierLabel">1 / 30</strong></div>
        <div><span>Upgrade Speed</span><strong id="speedLabel">Free</strong></div>
        <div><span>Score</span><strong id="scoreLabel">0</strong></div>
      </div>

      <div class="status">
        <div><span>Q Dash Bite</span><strong id="abQ">Ready</strong></div>
        <div><span>E Sonic Cry</span><strong id="abE">Ready</strong></div>
        <div><span>F Regen</span><strong id="abF">Ready</strong></div>
      </div>

      <div class="bar"><span id="xpBar"></span></div>
      <p class="small" id="xpText">XP: 0 / 50</p>
      <p class="small" id="foodText">Food: Tree 0 | Floor 0</p>

      <div class="status">
        <div><span>Network</span><strong id="netState">Offline</strong></div>
        <div><span>Players Online</span><strong id="onlineCount">1</strong></div>
      </div>
      <p class="small" id="leaderboardText">Leaderboard: local only</p>
      <p class="small" id="eventText">Event: Calm</p>
      <p class="small" id="questText">Quest: Eat 0 / 10</p>

      <div class="controls">
        Controls:
        `WASD` or `Arrow Keys` to move.
        `Shift` sprint (tight boost).
        `Space` jump on land.
        In air: hold `W`/`ArrowUp` to rise slowly, release to fall, `S`/`ArrowDown` to dive.
        `Q` dash bite, `E` sonic cry, `F` regen.
        `J` attack (Moon tiers 28-30 only).
        `R` tester respawn (if stuck).
        `1` buy Aero Plating, `2` buy Guard Weave, `3` buy Moon Edge (costs shown in HUD).
        Keybinds can be remapped in Settings -> Advanced Settings -> Controls.
        Some animals can eat tree food and/or floor food automatically on touch.
        Color rules: green ring = you can eat, red ring = neither side can eat, no ring = neutral/danger.
        At far right map edge, enter ice tunnel with `S` / `ArrowDown` / `Space`.
      </div>

      <section class="settings-section" id="settingsSection" aria-label="Settings">
        <h3 class="settings-title">Settings</h3>
        <p class="settings-desc" id="settingsSyncHint">Preferences save locally. Sign in to sync settings to your account.</p>

        <div class="preset-row" role="group" aria-label="Performance Presets">
          <button id="presetLowBtn" class="secondary preset-btn" type="button">Low</button>
          <button id="presetBalancedBtn" class="secondary preset-btn" type="button">Balanced</button>
          <button id="presetUltraBtn" class="secondary preset-btn" type="button">Ultra</button>
        </div>

        <div class="status">
            <div class="setting-row">
                <label for="qualitySelect">Graphics Quality <span class="label-help" title="Lower settings increase frame rate on slower devices.">?</span></label>
                <select id="qualitySelect">
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                  <option value="ultra" selected>Ultra</option>
                </select>
              </div>
              <div class="toggle-row">
                <span>Auto Performance <span class="label-help" title="Automatically lowers quality when FPS stays low for several seconds.">?</span></span>
                <input id="autoPerfToggle" type="checkbox" />
              </div>
              <div class="toggle-row">
                <span>Reduced Motion <span class="label-help" title="Reduces camera and environment motion effects for comfort.">?</span></span>
                <input id="reduceMotionToggle" type="checkbox" />
              </div>
              <div class="toggle-row">
                <span>Show Minimap <span class="label-help" title="Displays world position and key entities in the corner map.">?</span></span>
                <input id="minimapToggle" type="checkbox" />
              </div>
              <div class="toggle-row">
                <span>Detailed HUD Stats <span class="label-help" title="Shows extra run diagnostics like tunnel distance and nearby counts.">?</span></span>
                <input id="advancedHudToggle" type="checkbox" />
              </div>
              <div class="toggle-row">
                <span>Auto Save Progress <span class="label-help" title="Saves progress periodically during active matches.">?</span></span>
                <input id="autosaveToggle" type="checkbox" />
              </div>
            </div>

        <details class="advanced-settings" id="advancedSettings">
          <summary>Advanced Settings</summary>
          <div class="advanced-body">
            <p class="settings-subtitle">Accessibility</p>
            <div class="status">
              <div class="setting-row">
                <label for="textScaleSelect">Text Size <span class="label-help" title="Scales text in menus and HUD for readability.">?</span></label>
                <select id="textScaleSelect">
                  <option value="1">Default (100%)</option>
                  <option value="1.15">Large (115%)</option>
                  <option value="1.3">XL (130%)</option>
                </select>
              </div>
              <div class="toggle-row">
                <span>High Contrast UI <span class="label-help" title="Increases UI contrast between text and background.">?</span></span>
                <input id="highContrastToggle" type="checkbox" />
              </div>
              <div class="toggle-row">
                <span>Colorblind-safe Rings <span class="label-help" title="Switches prey/danger ring colors to high-distinction alternatives.">?</span></span>
                <input id="colorblindToggle" type="checkbox" />
              </div>
            </div>

            <p class="settings-subtitle">Audio (Disabled)</p>
            <div class="status audio-disabled" id="audioPanel">
              <p class="small">Audio is disabled for this build.</p>
              <div class="toggle-row">
                <span>Mute All <span class="label-help" title="Mutes both music and SFX output.">?</span></span>
                <input id="muteMasterToggle" type="checkbox" />
              </div>
              <div class="toggle-row">
                <span>Mute Music <span class="label-help" title="Keeps SFX active while disabling background music.">?</span></span>
                <input id="muteMusicToggle" type="checkbox" />
              </div>
              <div class="toggle-row">
                <span>Mute SFX <span class="label-help" title="Keeps music active while disabling action sounds.">?</span></span>
                <input id="muteSfxToggle" type="checkbox" />
              </div>
              <div class="slider-row">
                <label for="masterVolumeSlider">Master Volume</label>
                <span id="masterVolumeValue">80%</span>
              </div>
              <input id="masterVolumeSlider" type="range" min="0" max="100" step="1" value="80" />
              <div class="slider-row">
                <label for="musicVolumeSlider">Music Volume</label>
                <span id="musicVolumeValue">55%</span>
              </div>
              <input id="musicVolumeSlider" type="range" min="0" max="100" step="1" value="55" />
              <div class="slider-row">
                <label for="sfxVolumeSlider">SFX Volume</label>
                <span id="sfxVolumeValue">75%</span>
              </div>
              <input id="sfxVolumeSlider" type="range" min="0" max="100" step="1" value="75" />
            </div>

            <p class="settings-subtitle">Controls</p>
            <div class="status">
              <div class="bind-grid">
                <div class="bind-row"><span>Move Up</span><button class="secondary bind-btn" data-bind="moveUp" type="button">W</button></div>
                <div class="bind-row"><span>Move Down</span><button class="secondary bind-btn" data-bind="moveDown" type="button">S</button></div>
                <div class="bind-row"><span>Move Left</span><button class="secondary bind-btn" data-bind="moveLeft" type="button">A</button></div>
                <div class="bind-row"><span>Move Right</span><button class="secondary bind-btn" data-bind="moveRight" type="button">D</button></div>
                <div class="bind-row"><span>Sprint</span><button class="secondary bind-btn" data-bind="sprint" type="button">Shift</button></div>
                <div class="bind-row"><span>Jump</span><button class="secondary bind-btn" data-bind="jump" type="button">Space</button></div>
                <div class="bind-row"><span>Dash Bite</span><button class="secondary bind-btn" data-bind="abilityQ" type="button">Q</button></div>
                <div class="bind-row"><span>Sonic Cry</span><button class="secondary bind-btn" data-bind="abilityE" type="button">E</button></div>
                <div class="bind-row"><span>Regen</span><button class="secondary bind-btn" data-bind="abilityF" type="button">F</button></div>
                <div class="bind-row"><span>Moon Attack</span><button class="secondary bind-btn" data-bind="attack" type="button">J</button></div>
                <div class="bind-row"><span>Tester Respawn</span><button class="secondary bind-btn" data-bind="respawn" type="button">R</button></div>
                <div class="bind-row"><span>Toggle Minimap</span><button class="secondary bind-btn" data-bind="minimap" type="button">M</button></div>
              </div>
              <p class="small">Click a bind button, then press any key.</p>
              <button id="resetControlsBtn" class="secondary" type="button">Reset Controls</button>
            </div>
          </div>
        </details>

        <div class="settings-actions">
          <div class="settings-io">
            <button id="exportSettingsBtn" class="secondary" type="button">Export Settings</button>
            <button id="importSettingsBtn" class="secondary" type="button">Import Settings</button>
          </div>
          <input id="importSettingsFile" type="file" accept="application/json,.json" class="hidden-auth" />
          <button id="resetSettingsBtn" class="secondary" type="button">Reset All Settings</button>
        </div>
      </section>
    </section>

    <section class="panel game-wrap">
      <div class="top-hud">
        <div class="top-bar">
          <div class="top-pill">SkyBeast Arena | North America 1</div>
          <button id="playBtn" class="play-btn" type="button">PLAY</button>
        </div>
        <div class="guide-card">
          <b>How To Play</b>
          Eat creatures with green rings, avoid red-ring blocked targets, collect tree/floor food, and evolve through all 30 forms.
        </div>
      </div>
      <div class="start-screen" id="startScreen">
        <div class="start-card">
          <span class="start-chip">Preview Lobby</span>
          <h2>Arena Preview</h2>
          <p>Watch the world first, then join when ready.</p>
          <div class="start-list">
            `Play` to enter live mode and start moving.
            Logged-in users keep account XP/history.
            Each new match always starts at Tier 1.
            Flight unlocks at tier 6.
            Use `Settings` to configure before joining.
          </div>
          <button id="startBtn" class="start-btn" type="button">Play And Join</button>
          <button id="startSettingsBtn" class="secondary" type="button">Settings</button>
          <p class="small">Tip: press `Enter` to start quickly.</p>
        </div>
      </div>
      <canvas id="gameCanvas" width="900" height="680"></canvas>
      <div class="toast" id="toast">Tier Up!</div>
      <button class="overlay-toggle" id="togglePanelBtn">Show Panel (Tab)</button>
    </section>
  </main>

  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script>
    const tiers = [
      "Ant", "Mouse", "Rabbit", "Fox", "Wolf",
      "Falcon Pup", "Eagle Scout", "Hawk Rider", "Raven Glide", "Owl Hunter",
      "Condor", "Vulture King", "Albatross", "Golden Eagle", "Storm Falcon",
      "Thunder Hawk", "Phoenix", "Wyvern", "Drake", "Sky Serpent",
      "Sky Wolf", "Manticore", "Griffin", "Roc", "Tempest Dragon",
      "Celestial Dragon", "Sky Leviathan", "Moon 3", "Moon 2", "Moon 1"
    ];
    const tierProfiles = tiers.map((_, i) => {
      const t = i + 1;
      if (t <= 5) {
        return { base: "#9ec8ff", accent: "#2b4f7a", eye: "#0d1f33", type: "land" };
      }
      if (t >= 28) {
        return { base: "#f6f1dc", accent: "#d3b54f", eye: "#13202f", type: "moon" };
      }
      if (t >= 18) {
        return { base: "#ffd28b", accent: "#c46a2f", eye: "#291a0b", type: "dragon" };
      }
      return { base: "#d9e7ef", accent: "#4a6f86", eye: "#111d28", type: "air" };
    });
    const spriteManifest = {
      ant: "assets/sprites/ant.svg",
      mouse: "assets/sprites/mouse.svg",
      rabbit: "assets/sprites/rabbit.svg",
      fox: "assets/sprites/fox.svg",
      eagle: "assets/sprites/eagle.svg",
      owl: "assets/sprites/owl.svg",
      dragon: "assets/sprites/dragon.svg",
      moon: "assets/sprites/moon.svg",
      moon3: "assets/sprites/moon3.svg",
      moon2: "assets/sprites/moon2.svg",
      moon1: "assets/sprites/moon1.svg"
    };
    const spriteCache = {};
    const SPRITE_VERSION = "v7";
    const foodSpriteManifest = {
      apple: "assets/sprites/apple.svg",
      banana: "assets/sprites/banana.svg",
      berry: "assets/sprites/berry.svg",
      carrot: "assets/sprites/carrot.svg",
      pumpkin: "assets/sprites/pumpkin.svg",
      mushroom: "assets/sprites/mushroom.svg"
    };
    const foodSpriteCache = {};

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const WORLD = {
      width: 600000,
      height: 150000
    };
    const BIOME_WIDTH = 18000;
    const biomeDefs = [
      {
        name: "Greenwood",
        skyTop: "#6fa7d3",
        skyMid: "#92c7e8",
        skyLow: "#b5def1",
        groundTop: "rgba(74,116,61,0.88)",
        groundBottom: "rgba(42,82,40,0.95)"
      },
      {
        name: "Amber Dunes",
        skyTop: "#c59763",
        skyMid: "#dfbf85",
        skyLow: "#efd7a3",
        groundTop: "rgba(140,112,58,0.88)",
        groundBottom: "rgba(99,72,35,0.95)"
      },
      {
        name: "Frost Reach",
        skyTop: "#7aa9cf",
        skyMid: "#a6d0e9",
        skyLow: "#d3ecf8",
        groundTop: "rgba(98,130,136,0.88)",
        groundBottom: "rgba(62,88,96,0.95)"
      },
      {
        name: "Ash Ridge",
        skyTop: "#8a879e",
        skyMid: "#aba8c0",
        skyLow: "#c8c6da",
        groundTop: "rgba(104,96,92,0.9)",
        groundBottom: "rgba(60,55,54,0.95)"
      }
    ];
    const zoneTierBands = [
      { min: 1, max: 4 },
      { min: 3, max: 8 },
      { min: 6, max: 12 },
      { min: 10, max: 18 },
      { min: 15, max: 24 },
      { min: 20, max: 30 }
    ];
    const hazardZones = [
      { start: WORLD.width * 0.23, end: WORLD.width * 0.29, type: "lava", dps: 16 },
      { start: WORLD.width * 0.52, end: WORLD.width * 0.58, type: "acid", dps: 12 },
      { start: WORLD.width * 0.77, end: WORLD.width * 0.83, type: "storm", dps: 10 }
    ];
    const landmarkDefs = [
      { name: "Sun Orchard", x: WORLD.width * 0.07, type: "orchard" },
      { name: "Howler Dunes", x: WORLD.width * 0.17, type: "dunes" },
      { name: "Crystal Nest", x: WORLD.width * 0.29, type: "crystal" },
      { name: "Moss Ruins", x: WORLD.width * 0.38, type: "ruins" },
      { name: "Icelake Spire", x: WORLD.width * 0.49, type: "frost" },
      { name: "Storm Fangs", x: WORLD.width * 0.61, type: "storm" },
      { name: "Ash Graveyard", x: WORLD.width * 0.74, type: "grave" },
      { name: "Moon Shrine", x: WORLD.width * 0.88, type: "moon" }
    ];
    const objectiveTemplates = [
      { type: "eat_any", label: "Hunt creatures", target: 8, rewardXp: 210, rewardScore: 145, time: 170 },
      { type: "eat_air", label: "Catch flying creatures", target: 5, rewardXp: 230, rewardScore: 165, time: 170 },
      { type: "eat_tree", label: "Gather tree food", target: 7, rewardXp: 190, rewardScore: 135, time: 160 },
      { type: "eat_floor", label: "Gather floor food", target: 7, rewardXp: 190, rewardScore: 135, time: 160 },
      { type: "eat_elite", label: "Defeat elite creatures", target: 3, rewardXp: 280, rewardScore: 205, time: 180 },
      { type: "boss_hit", label: "Damage biome boss", target: 2, rewardXp: 320, rewardScore: 235, time: 185 }
    ];
    const bossDefs = {
      Greenwood: { name: "Thorn King", kind: "ground", accent: "#7fdc74", hpMult: 1.05, minTier: 8 },
      "Amber Dunes": { name: "Dune Talon", kind: "air", accent: "#ffd07a", hpMult: 1.1, minTier: 11 },
      "Frost Reach": { name: "Glacier Wyrm", kind: "air", accent: "#8de7ff", hpMult: 1.2, minTier: 16 },
      "Ash Ridge": { name: "Cinder Reaper", kind: "air", accent: "#ff9f8e", hpMult: 1.28, minTier: 21 }
    };

    const TUNNEL = {
      entranceX: WORLD.width - 260,
      entranceW: 180,
      entranceH: 110,
      exitX: 220
    };
    const BOT_TARGET = 16;
    const FOOD_TARGET = 34;
    const MIN_FLYING_BOTS = 5;
    const MIN_GROUND_BOTS = 7;
    const MIN_EDIBLE_BOTS = 6;
    const MOVEMENT = {
      landMax: 365,
      airMax: 430,
      sprintMult: 1.16,
      accelGround: 2080,
      accelAir: 1900,
      frictionGround: 11.8,
      airAccelResponse: 5.9,
      airBrakeResponse: 4.6,
      airTurnResponse: 8.4,
      airClimbSpeed: 220,
      airHoverClimbSpeed: 158,
      airSinkSpeed: 104,
      airDiveSpeed: 282,
      airVerticalResponse: 5.6,
      airLiftBoost: 132,
      airForwardLift: 46,
      airNearGroundAssist: 36,
      airVerticalMax: 392,
      gravity: 1240,
      fallGravityMult: 1.06,
      maxFall: 840,
      jumpSpeed: 592,
      jumpCutMult: 0.35,
      coyoteTime: 0.16,
      jumpBufferTime: 0.16
    };
    const VISUALS = {
      interactionRingDistance: 560,
      interactionLabelDistance: 84,
      resourceHintDistance: 520,
      ringPulseSpeed: 6.4,
      ambientParticles: {
        medium: 28,
        high: 44,
        ultra: 68
      }
    };
    const CAMERA = {
      deadZoneXRatio: 0.2,
      deadZoneYRatio: 0.14,
      lookAheadXRatio: 0.14,
      lookAheadYRatio: 0.06,
      lookAheadXMax: 92,
      lookAheadYMax: 54,
      followX: 4.2,
      followY: 3.8,
      followXReduce: 3.4,
      followYReduce: 3.1
    };
    const LOOT_SHOP = Object.freeze({
      aero: {
        label: "Aero Plating",
        key: "1",
        costs: [5, 9, 14, 20]
      },
      guard: {
        label: "Guard Weave",
        key: "2",
        costs: [6, 11, 17, 24]
      },
      moon: {
        label: "Moon Edge",
        key: "3",
        costs: [6, 10, 16, 23]
      }
    });

    const ui = {
      formName: document.getElementById("formName"),
      tierLabel: document.getElementById("tierLabel"),
      speedLabel: document.getElementById("speedLabel"),
      scoreLabel: document.getElementById("scoreLabel"),
      abQ: document.getElementById("abQ"),
      abE: document.getElementById("abE"),
      abF: document.getElementById("abF"),
      netState: document.getElementById("netState"),
      onlineCount: document.getElementById("onlineCount"),
      leaderboardText: document.getElementById("leaderboardText"),
      eventText: document.getElementById("eventText"),
      questText: document.getElementById("questText"),
      xpBar: document.getElementById("xpBar"),
      xpText: document.getElementById("xpText"),
      foodText: document.getElementById("foodText"),
      accountState: document.getElementById("accountState"),
      toast: document.getElementById("toast"),
      signupBtn: document.getElementById("signupBtn"),
      googleBtn: document.getElementById("googleBtn"),
      googleRender: document.getElementById("googleRender"),
      googleHint: document.getElementById("googleHint"),
      progressHint: document.getElementById("progressHint"),
      profileCard: document.getElementById("profileCard"),
      profileMeta: document.getElementById("profileMeta"),
      logoutBtn: document.getElementById("logoutBtn"),
      settingsSection: document.getElementById("settingsSection"),
      settingsSyncHint: document.getElementById("settingsSyncHint"),
      presetLowBtn: document.getElementById("presetLowBtn"),
      presetBalancedBtn: document.getElementById("presetBalancedBtn"),
      presetUltraBtn: document.getElementById("presetUltraBtn"),
      qualitySelect: document.getElementById("qualitySelect"),
      autoPerfToggle: document.getElementById("autoPerfToggle"),
      reduceMotionToggle: document.getElementById("reduceMotionToggle"),
      minimapToggle: document.getElementById("minimapToggle"),
      advancedHudToggle: document.getElementById("advancedHudToggle"),
      autosaveToggle: document.getElementById("autosaveToggle"),
      textScaleSelect: document.getElementById("textScaleSelect"),
      highContrastToggle: document.getElementById("highContrastToggle"),
      colorblindToggle: document.getElementById("colorblindToggle"),
      audioPanel: document.getElementById("audioPanel"),
      muteMasterToggle: document.getElementById("muteMasterToggle"),
      muteMusicToggle: document.getElementById("muteMusicToggle"),
      muteSfxToggle: document.getElementById("muteSfxToggle"),
      masterVolumeSlider: document.getElementById("masterVolumeSlider"),
      musicVolumeSlider: document.getElementById("musicVolumeSlider"),
      sfxVolumeSlider: document.getElementById("sfxVolumeSlider"),
      masterVolumeValue: document.getElementById("masterVolumeValue"),
      musicVolumeValue: document.getElementById("musicVolumeValue"),
      sfxVolumeValue: document.getElementById("sfxVolumeValue"),
      resetControlsBtn: document.getElementById("resetControlsBtn"),
      advancedSettings: document.getElementById("advancedSettings"),
      exportSettingsBtn: document.getElementById("exportSettingsBtn"),
      importSettingsBtn: document.getElementById("importSettingsBtn"),
      importSettingsFile: document.getElementById("importSettingsFile"),
      resetSettingsBtn: document.getElementById("resetSettingsBtn"),
      playBtn: document.getElementById("playBtn"),
      startBtn: document.getElementById("startBtn"),
      startSettingsBtn: document.getElementById("startSettingsBtn"),
      startScreen: document.getElementById("startScreen"),
      appRoot: document.getElementById("appRoot"),
      togglePanelBtn: document.getElementById("togglePanelBtn"),
      controlPanel: document.getElementById("controlPanel"),
      subBtn: document.getElementById("subBtn"),
      playerName: document.getElementById("playerName"),
      playerEmail: document.getElementById("playerEmail"),
      bindButtons: Array.from(document.querySelectorAll(".bind-btn"))
    };

    const DEFAULT_CONTROL_BINDINGS = Object.freeze({
      moveUp: "KeyW",
      moveDown: "KeyS",
      moveLeft: "KeyA",
      moveRight: "KeyD",
      sprint: "ShiftLeft",
      jump: "Space",
      abilityQ: "KeyQ",
      abilityE: "KeyE",
      abilityF: "KeyF",
      attack: "KeyJ",
      respawn: "KeyR",
      minimap: "KeyM"
    });

    const DEFAULT_AUDIO_SETTINGS = Object.freeze({
      masterVolume: 0,
      musicVolume: 0,
      sfxVolume: 0,
      muteMaster: true,
      muteMusic: true,
      muteSfx: true
    });
    const AUDIO_ENABLED = false;
    const SETTINGS_SCHEMA_VERSION = 2;
    const SETTINGS_EXPORT_APP = "skybeast_ascension";

    const DEFAULT_LOCAL_SETTINGS = Object.freeze({
      quality: "ultra",
      reduceMotion: false,
      showMiniMap: false,
      advancedHud: true,
      autoSave: true,
      autoPerformance: true,
      highContrast: false,
      colorblindSafe: false,
      textScale: 1
    });

    const state = {
      signedUp: false,
      authProvider: null,
      subscribed: false,
      score: 0,
      player: {
        x: 180,
        y: 0,
        vx: 0,
        vy: 0,
        size: 41,
        tier: 1,
        xp: 0,
        xpToNext: 50,
        facing: 1,
        moonCombo: 0,
        grounded: false,
        coyoteTimer: 0,
        jumpBufferTimer: 0,
        hp: 100,
        invulnTimer: 0,
        flapCd: 0,
        attackCd: 0,
        tunnelCd: 0
      },
      camera: {
        x: 0,
        y: 0
      },
      bots: [],
      resources: [],
      keys: {},
      controlCapture: null,
      input: {
        jumpQueued: false
      },
      net: {
        id: null,
        socket: null,
        connected: false,
        remotePlayers: {},
        onlineCount: 1,
        leaderboard: []
      },
      abilities: {
        q: { cd: 0, max: 4.5 },
        e: { cd: 0, max: 8 },
        f: { cd: 0, max: 11 }
      },
      worldEvent: {
        type: "Calm",
        timer: 26
      },
      currentBiome: "Greenwood",
      visual: {
        dayPhase: 0.28
      },
      quality: DEFAULT_LOCAL_SETTINGS.quality,
      settings: {
        reduceMotion: DEFAULT_LOCAL_SETTINGS.reduceMotion,
        advancedHud: DEFAULT_LOCAL_SETTINGS.advancedHud,
        autoSave: DEFAULT_LOCAL_SETTINGS.autoSave,
        autoPerformance: DEFAULT_LOCAL_SETTINGS.autoPerformance,
        highContrast: DEFAULT_LOCAL_SETTINGS.highContrast,
        colorblindSafe: DEFAULT_LOCAL_SETTINGS.colorblindSafe,
        textScale: DEFAULT_LOCAL_SETTINGS.textScale,
        preset: "ultra"
      },
      controls: { ...DEFAULT_CONTROL_BINDINGS },
      audioSettings: { ...DEFAULT_AUDIO_SETTINGS },
      audio: {
        ready: false,
        ctx: null,
        masterGain: null,
        musicGain: null,
        sfxGain: null,
        musicOscA: null,
        musicOscB: null,
        musicLfo: null,
        musicLfoGain: null
      },
      performance: {
        lowFpsTimer: 0,
        cooldown: 0
      },
      gfx: {
        soilPattern: null
      },
      quest: {
        progress: 0,
        target: 10,
        rewardXp: 180,
        rewardScore: 120
      },
      biomeMission: {
        biome: "Greenwood",
        type: "tree_food",
        progress: 0,
        target: 6,
        rewardXp: 140,
        rewardScore: 90
      },
      foodStats: {
        tree: 0,
        floor: 0
      },
      googleClientId: "",
      googleSdkPromise: null,
      googleButtonRendered: false,
      googleInitialized: false,
      netSendTimer: 0,
      lastTime: 0,
      hudFps: 60,
      loop: {
        accumulator: 0,
        fixedDt: 1 / 90,
        maxSubSteps: 5
      },
      gameStarted: false,
      showMiniMap: DEFAULT_LOCAL_SETTINGS.showMiniMap,
      bosses: [],
      bossSystem: {
        cooldown: 8,
        maxActive: 2
      },
      combatTexts: [],
      survival: {
        energy: 100,
        hydration: 100,
        oxygen: 100,
        tickDamageCd: 0
      },
      objective: {
        type: "eat_any",
        label: "Hunt creatures",
        progress: 0,
        target: 8,
        rewardXp: 210,
        rewardScore: 145,
        timeLeft: 170,
        maxTime: 170
      },
      objectiveStats: {
        difficulty: 0,
        lastDuration: 0,
        completed: 0
      },
      loot: {
        relics: 0,
        shards: 0,
        cores: 0,
        upgrades: {
          aero: 0,
          guard: 0,
          moon: 0
        }
      },
      spawnDirector: {
        preyPulse: 0,
        threatPulse: 0,
        landmarkPulse: 0
      },
      fx: {
        hitStop: 0,
        hitFlash: 0,
        shakeTime: 0,
        shakePower: 0
      },
      death: {
        lastX: null,
        lastY: null,
        reason: "",
        tier: 1,
        streakLost: 0,
        revengeActive: false,
        revengeXp: 120
      },
      progression: {
        runBadges: {
          hunter: false,
          survivor: false,
          apex: false,
          boss: false
        }
      },
      account: {
        tier: 1,
        xp: 0,
        xpToNext: 50,
        score: 0,
        lifetimeXp: 0
      },
      match: {
        spawnShield: 0,
        respawnTimer: 0,
        deathReason: "",
        streak: 0,
        bestStreak: 0,
        killfeed: [],
        bountyScore: 600,
        bountyStep: 600
      },
      ecosystem: {
        rareFoodTimer: 12
      }
    };

    const ACTION_FALLBACK_CODES = Object.freeze({
      moveUp: ["ArrowUp"],
      moveDown: ["ArrowDown"],
      moveLeft: ["ArrowLeft"],
      moveRight: ["ArrowRight"],
      sprint: ["ShiftLeft", "ShiftRight"]
    });

    const CONTROL_LABELS = Object.freeze({
      moveUp: "Move Up",
      moveDown: "Move Down",
      moveLeft: "Move Left",
      moveRight: "Move Right",
      sprint: "Sprint",
      jump: "Jump",
      abilityQ: "Dash Bite",
      abilityE: "Sonic Cry",
      abilityF: "Regen",
      attack: "Moon Attack",
      respawn: "Tester Respawn",
      minimap: "Toggle Minimap"
    });

    const NON_REMAPPABLE_CODES = new Set(["Tab"]);
    let toastTimer = null;

    function groundY(x) {
      const hills = Math.sin(x * 0.0023) * 70 + Math.sin(x * 0.0059) * 28;
      return WORLD.height * 0.78 + hills;
    }

    function isAirTier(tier) {
      return tier >= 6;
    }

    function isMoonTier(tier) {
      return tier >= 28;
    }

    function canConsume(playerTier, targetTier) {
      if (targetTier > playerTier) return false;
      if (isMoonTier(playerTier)) return true;
      const delta = playerTier - targetTier;
      if (playerTier <= 5) return delta <= 3;
      if (playerTier <= 12) return delta <= 4;
      if (playerTier <= 20) return delta <= 5;
      return delta <= 6;
    }

    function interactionState(playerTier, targetTier) {
      const youEat = canConsume(playerTier, targetTier);
      const theyEat = canConsume(targetTier, playerTier);
      if (youEat) return "prey";
      if (!youEat && !theyEat) return "blocked";
      return "neutral";
    }

    function pushKillfeed(text, color = "#dbeeff") {
      state.match.killfeed.unshift({
        text,
        color,
        ttl: 8
      });
      if (state.match.killfeed.length > 6) state.match.killfeed.length = 6;
    }

    function xpMultiplier() {
      return state.subscribed ? 1.6 : 1;
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function numberOr(value, fallback) {
      const n = Number(value);
      return Number.isFinite(n) ? n : fallback;
    }

    function readableKey(code) {
      if (!code) return "Unbound";
      if (code === "Space") return "Space";
      if (code.startsWith("Key")) return code.slice(3).toUpperCase();
      if (code.startsWith("Digit")) return code.slice(5);
      if (code.startsWith("Numpad")) return `Num ${code.slice(6)}`;
      if (code.startsWith("Arrow")) return code.slice(5);
      if (code === "ShiftLeft" || code === "ShiftRight") return "Shift";
      if (code === "ControlLeft" || code === "ControlRight") return "Ctrl";
      if (code === "AltLeft" || code === "AltRight") return "Alt";
      return code;
    }

    function actionCode(action) {
      return state.controls[action] || DEFAULT_CONTROL_BINDINGS[action] || "";
    }

    function isActionPressed(action) {
      const primary = actionCode(action);
      if (primary && state.keys[primary]) return true;
      const fallback = ACTION_FALLBACK_CODES[action] || [];
      for (const code of fallback) {
        if (state.keys[code]) return true;
      }
      return false;
    }

    function eventMatchesAction(e, action) {
      const code = String(e.code || "");
      if (!code) return false;
      if (code === actionCode(action)) return true;
      const fallback = ACTION_FALLBACK_CODES[action] || [];
      return fallback.includes(code);
    }

    function interactionPalette() {
      if (state.settings.colorblindSafe) {
        return {
          preyRing: "rgba(86,162,255,0.97)",
          dangerRing: "rgba(255,186,86,0.95)",
          blockedRing: "rgba(255,122,86,0.95)",
          dangerFill: "rgba(255,186,86,0.14)",
          ediblePointer: "#83c4ff",
          dangerPointer: "#ffc67f",
          hudChipRing: "#83c4ff"
        };
      }
      return {
        preyRing: "rgba(80,230,130,0.97)",
        dangerRing: "rgba(255,102,102,0.95)",
        blockedRing: "rgba(240,85,85,0.95)",
        dangerFill: "rgba(255,88,88,0.14)",
        ediblePointer: "#78f7a9",
        dangerPointer: "#ff8f8f",
        hudChipRing: "#59ec8e"
      };
    }

    function inferPresetName() {
      if (state.quality === "ultra" && !state.settings.reduceMotion && state.settings.advancedHud) {
        return "ultra";
      }
      if (state.quality === "high" && !state.settings.reduceMotion && state.settings.advancedHud) {
        return "balanced";
      }
      if (state.quality === "medium" && state.settings.reduceMotion && !state.settings.advancedHud) {
        return "low";
      }
      return "custom";
    }

    function syncPresetButtons() {
      const preset = inferPresetName();
      ui.presetLowBtn.classList.toggle("active", preset === "low");
      ui.presetBalancedBtn.classList.toggle("active", preset === "balanced");
      ui.presetUltraBtn.classList.toggle("active", preset === "ultra");
      state.settings.preset = preset;
    }

    function updateSettingsSyncHint() {
      if (!ui.settingsSyncHint) return;
      ui.settingsSyncHint.textContent = state.signedUp
        ? "Preferences are synced to your account."
        : "Preferences save locally. Sign in to sync settings to your account.";
    }

    function applyAccessibilitySettings() {
      document.documentElement.style.setProperty("--ui-scale", String(state.settings.textScale || 1));
      document.body.classList.toggle("high-contrast", !!state.settings.highContrast);
    }

    function hardMuteAudioSettings() {
      state.audioSettings.masterVolume = 0;
      state.audioSettings.musicVolume = 0;
      state.audioSettings.sfxVolume = 0;
      state.audioSettings.muteMaster = true;
      state.audioSettings.muteMusic = true;
      state.audioSettings.muteSfx = true;
    }

    function disableAudioUi() {
      if (ui.audioPanel) ui.audioPanel.classList.add("audio-disabled");
      const controls = [
        ui.muteMasterToggle,
        ui.muteMusicToggle,
        ui.muteSfxToggle,
        ui.masterVolumeSlider,
        ui.musicVolumeSlider,
        ui.sfxVolumeSlider
      ];
      for (const control of controls) {
        if (!control) continue;
        control.disabled = true;
      }
    }

    function syncVolumeLabels() {
      if (!AUDIO_ENABLED) {
        ui.masterVolumeValue.textContent = "OFF";
        ui.musicVolumeValue.textContent = "OFF";
        ui.sfxVolumeValue.textContent = "OFF";
        return;
      }
      ui.masterVolumeValue.textContent = `${Math.round((state.audioSettings.masterVolume || 0) * 100)}%`;
      ui.musicVolumeValue.textContent = `${Math.round((state.audioSettings.musicVolume || 0) * 100)}%`;
      ui.sfxVolumeValue.textContent = `${Math.round((state.audioSettings.sfxVolume || 0) * 100)}%`;
    }

    function renderControlBindingsUi() {
      for (const btn of ui.bindButtons) {
        const action = btn.dataset.bind;
        if (!action) continue;
        const listening = state.controlCapture === action;
        btn.classList.toggle("listening", listening);
        btn.textContent = listening ? "Press key..." : readableKey(actionCode(action));
      }
    }

    function biomeAtX(x) {
      const idx = ((Math.floor(clamp(x, 0, WORLD.width - 1) / BIOME_WIDTH) % biomeDefs.length) + biomeDefs.length) % biomeDefs.length;
      return biomeDefs[idx];
    }

    function zoneTierBandAtX(x) {
      const ratio = clamp(x / WORLD.width, 0, 0.999999);
      const idx = Math.floor(ratio * zoneTierBands.length);
      return zoneTierBands[clamp(idx, 0, zoneTierBands.length - 1)];
    }

    function biomeMissionTemplate(biomeName) {
      if (biomeName === "Amber Dunes") {
        return { type: "ground_bots", target: 6, rewardXp: 180, rewardScore: 120, label: "Defeat ground creatures" };
      }
      if (biomeName === "Frost Reach") {
        return { type: "air_bots", target: 6, rewardXp: 190, rewardScore: 130, label: "Defeat flying creatures" };
      }
      if (biomeName === "Ash Ridge") {
        return { type: "elite_bots", target: 4, rewardXp: 220, rewardScore: 160, label: "Defeat elite creatures" };
      }
      return { type: "tree_food", target: 8, rewardXp: 150, rewardScore: 100, label: "Gather tree food" };
    }

    function setBiomeMission(biomeName) {
      const tpl = biomeMissionTemplate(biomeName);
      state.biomeMission = {
        biome: biomeName,
        type: tpl.type,
        progress: 0,
        target: tpl.target,
        rewardXp: tpl.rewardXp,
        rewardScore: tpl.rewardScore
      };
    }

    function biomeMissionLabel() {
      const m = state.biomeMission;
      const tpl = biomeMissionTemplate(m.biome);
      return tpl.label;
    }

    function addBiomeMissionProgress(amount) {
      const m = state.biomeMission;
      if (!m || amount <= 0) return;
      m.progress += amount;
      const p = state.player;
      while (m.progress >= m.target) {
        m.progress -= m.target;
        p.xp += m.rewardXp;
        state.score += m.rewardScore;
        m.target = Math.min(18, m.target + 1);
        m.rewardXp = Math.floor(m.rewardXp * 1.1 + 20);
        m.rewardScore = Math.floor(m.rewardScore * 1.1 + 15);
        showToast(`Biome mission complete: +${m.rewardXp} XP`);
      }
    }

    function bossTemplateForBiome(biomeName) {
      return bossDefs[biomeName] || bossDefs.Greenwood;
    }

    function canSpawnBoss() {
      if (state.player.tier < 4) return false;
      if (state.bosses.length >= state.bossSystem.maxActive) return false;
      return state.bossSystem.cooldown <= 0;
    }

    function spawnBoss(biomeName = state.currentBiome) {
      const tpl = bossTemplateForBiome(biomeName);
      const offset = randomInt(900, 1900) * (Math.random() < 0.5 ? -1 : 1);
      const x = clamp(state.player.x + offset, 120, WORLD.width - 120);
      const biome = biomeAtX(x).name;
      const zone = zoneTierBandAtX(x);
      const targetTier = clamp(Math.max(tpl.minTier, zone.max + 2, state.player.tier + 2), 7, 30);
      const ground = groundY(x);
      const y = tpl.kind === "air"
        ? clamp(ground - randomInt(170, 330), 110, WORLD.height - 360)
        : ground;
      const size = entitySizeForTier(targetTier) * 1.45;
      const maxHp = Math.floor((160 + targetTier * 30) * tpl.hpMult);

      state.bosses.push({
        id: `${Date.now()}_${Math.floor(Math.random() * 9999)}`,
        name: tpl.name,
        biome,
        kind: tpl.kind,
        accent: tpl.accent,
        x,
        y,
        vx: (Math.random() - 0.5) * 40,
        vy: 0,
        tier: targetTier,
        size,
        hp: maxHp,
        maxHp,
        phase: 1,
        enraged: false,
        abilityCd: randomInt(4, 7) * 0.6,
        telegraph: null,
        hitCd: 0,
        despawnTimer: 70
      });
      state.bossSystem.cooldown = randomInt(24, 38);
      showToast(`Biome Boss spawned: ${tpl.name}`);
    }

    function rewardBossDefeat(boss) {
      const baseXp = Math.floor(280 + boss.tier * 46);
      const baseScore = Math.floor(220 + boss.tier * 30);
      state.player.xp += baseXp * xpMultiplier();
      state.score += baseScore;
      const loot = rollBossLoot(boss);
      awardLoot(loot, `${boss.name} loot`);
      addCombatText(boss.x, boss.y - boss.size * 0.9, `BOSS +${baseXp} XP`, "#9df0ff", 17);
      addObjectiveProgress("boss_hit", 1);
      registerRunBadge("boss", "Boss Breaker", 260, 130);
      addBiomeMissionProgress(2);
      state.quest.progress += 2;
      state.bossSystem.cooldown = randomInt(16, 26);
      for (let i = 0; i < 4; i++) {
        const source = i % 2 === 0 ? "tree" : "floor";
        const nutrition = Math.random() < 0.7 ? "plant" : "meat";
        const x = clamp(boss.x + randomInt(-180, 180), 60, WORLD.width - 60);
        const y = source === "tree"
          ? groundY(x) - randomInt(90, 160)
          : groundY(x) - randomInt(4, 10);
        const size = source === "tree" ? randomInt(8, 12) : randomInt(9, 13);
        const item = source === "tree"
          ? (nutrition === "plant" ? (Math.random() < 0.5 ? "apple" : "banana") : "berry")
          : (nutrition === "plant" ? (Math.random() < 0.5 ? "carrot" : "pumpkin") : "mushroom");
        state.resources.push({
          x,
          y,
          size,
          source,
          nutrition,
          item,
          xp: Math.floor(24 + boss.tier * 1.5),
          score: Math.floor(12 + boss.tier * 1.1)
        });
      }
      applyImpactFx(0.92, 0.2, 0.016);
      showToast(`Boss defeated: ${boss.name} (+${baseXp} XP)`);
    }

    function entitySizeForTier(tier) {
      return 40 + tier * 1.35;
    }

    function estimatedLifetimeXp(tier, currentXp) {
      let needed = 50;
      let total = 0;
      for (let t = 1; t < tier; t++) {
        total += needed;
        needed = Math.floor(needed * 1.18 + 20);
      }
      total += Math.max(0, Math.floor(currentXp || 0));
      return total;
    }

    function defaultQuestState() {
      return {
        progress: 0,
        target: 10,
        rewardXp: 180,
        rewardScore: 120
      };
    }

    function tierPerkProfile(tier) {
      return {
        speedBoost: tier >= 6 ? 1.05 : 1,
        forageBoost: tier >= 12 ? 1.1 : 1,
        cooldownMult: tier >= 18 ? 0.9 : 1,
        sustainMult: tier >= 24 ? 0.86 : 1,
        moonPower: tier >= 30 ? 1.16 : 1
      };
    }

    function upgradeLevel(id) {
      return state.loot?.upgrades?.[id] || 0;
    }

    function upgradeCost(id) {
      const def = LOOT_SHOP[id];
      if (!def) return null;
      const lvl = upgradeLevel(id);
      if (lvl >= def.costs.length) return null;
      return def.costs[lvl];
    }

    function speedUpgradeMultiplier() {
      const lvl = upgradeLevel("aero");
      const shardBonus = Math.min(0.08, state.loot.shards * 0.004);
      return 1 + lvl * 0.04 + shardBonus;
    }

    function damageTakenMultiplier() {
      const lvl = upgradeLevel("guard");
      const coreReduction = Math.min(0.12, state.loot.cores * 0.03);
      return Math.max(0.52, 1 - lvl * 0.09 - coreReduction);
    }

    function moonDamageMultiplier() {
      const lvl = upgradeLevel("moon");
      const bonus = Math.min(0.18, state.loot.shards * 0.02 + state.loot.cores * 0.04);
      return 1 + lvl * 0.12 + bonus;
    }

    function awardLoot({ relics = 0, shards = 0, cores = 0 } = {}, reason = "") {
      if (relics <= 0 && shards <= 0 && cores <= 0) return;
      state.loot.relics += relics;
      state.loot.shards += shards;
      state.loot.cores += cores;
      const parts = [];
      if (relics > 0) parts.push(`+${relics} relic`);
      if (shards > 0) parts.push(`+${shards} shard`);
      if (cores > 0) parts.push(`+${cores} core`);
      const label = parts.join(" ");
      addCombatText(state.player.x, state.player.y - state.player.size * 0.95, label, "#9cf6ff", 13);
      pushKillfeed(`${reason ? `${reason}: ` : ""}${label}`, "#9cf6ff");
    }

    function rollBossLoot(boss) {
      const phase = boss.phase || 1;
      const tierBonus = Math.max(0, Math.floor((boss.tier - 8) / 6));
      const relics = randomInt(2 + phase, 4 + phase + tierBonus);
      const shards = phase >= 2 ? randomInt(1, 1 + Math.floor(phase / 2)) : 0;
      const coreChance = phase >= 3 ? 0.55 : (phase === 2 ? 0.25 : 0.1);
      const cores = Math.random() < coreChance ? 1 : 0;
      return { relics, shards, cores };
    }

    function tryBuyLootUpgrade(id) {
      const def = LOOT_SHOP[id];
      if (!def) return false;
      const lvl = upgradeLevel(id);
      const cost = upgradeCost(id);
      if (cost == null) {
        showToast(`${def.label} is maxed`);
        return false;
      }
      if (state.loot.relics < cost) {
        showToast(`${def.label}: need ${cost} relics`);
        return false;
      }
      state.loot.relics -= cost;
      state.loot.upgrades[id] = lvl + 1;
      pushKillfeed(`Upgrade bought: ${def.label} Lv.${lvl + 1}`, "#ffe89d");
      showToast(`${def.label} upgraded to Lv.${lvl + 1}`);
      applyImpactFx(0.5, 0.08, 0.004);
      return true;
    }

    function defaultObjectiveState() {
      return {
        type: "eat_any",
        label: "Hunt creatures",
        progress: 0,
        target: 8,
        rewardXp: 210,
        rewardScore: 145,
        timeLeft: 170,
        maxTime: 170
      };
    }

    function chooseObjectiveTemplate() {
      const p = state.player;
      const pool = objectiveTemplates.filter((t) => {
        if (t.type === "eat_air" && p.tier < 6) return false;
        if (t.type === "eat_elite" && p.tier < 8) return false;
        if (t.type === "boss_hit" && p.tier < 10) return false;
        if (t.type === "boss_hit" && state.bosses.length === 0 && state.bossSystem.cooldown > 12) return false;
        return true;
      });
      if (!pool.length) return objectiveTemplates[0];
      return pool[randomInt(0, pool.length - 1)];
    }

    function setNextObjective(reason = "new") {
      const tpl = chooseObjectiveTemplate();
      const diff = clamp(state.objectiveStats?.difficulty || 0, -2, 2);
      const target = Math.max(3, tpl.target + diff);
      const time = Math.max(95, Math.round(tpl.time * (1 - diff * 0.08)));
      const rewardMult = 1 + diff * 0.07;
      state.objective = {
        type: tpl.type,
        label: tpl.label,
        progress: 0,
        target,
        rewardXp: Math.round(tpl.rewardXp * rewardMult),
        rewardScore: Math.round(tpl.rewardScore * rewardMult),
        timeLeft: time,
        maxTime: time
      };
      if (reason !== "silent") {
        pushKillfeed(`Objective: ${tpl.label} (${target})`, "#bde4ff");
      }
    }

    function addObjectiveProgress(type, amount = 1) {
      if (!state.objective || amount <= 0) return;
      const o = state.objective;
      if (o.type !== type) return;
      o.progress += amount;
      if (o.progress < o.target) return;
      const rewardXp = Math.floor(o.rewardXp * xpMultiplier());
      state.player.xp += rewardXp;
      state.score += o.rewardScore;
      const relicReward = o.type === "boss_hit" ? 2 : 1;
      awardLoot({ relics: relicReward }, "Objective");
      state.objectiveStats.lastDuration = Math.max(0, o.maxTime - o.timeLeft);
      state.objectiveStats.completed += 1;
      const paceRatio = o.maxTime > 0 ? state.objectiveStats.lastDuration / o.maxTime : 1;
      if (paceRatio < 0.45) {
        state.objectiveStats.difficulty = clamp((state.objectiveStats.difficulty || 0) + 1, -2, 2);
      } else if (paceRatio > 0.92) {
        state.objectiveStats.difficulty = clamp((state.objectiveStats.difficulty || 0) - 1, -2, 2);
      }
      addCombatText(state.player.x, state.player.y - state.player.size * 0.9, `OBJECTIVE +${rewardXp} XP`, "#b8f6ff", 15);
      pushKillfeed(`Objective complete (+${rewardXp} XP)`, "#b8f6ff");
      showToast("Objective complete");
      applyImpactFx(0.65, 0.16, 0.012);
      setNextObjective("complete");
    }

    function applyImpactFx(power = 0.5, flash = 0.12, stop = 0.01) {
      const fx = state.fx;
      const motionMult = state.settings.reduceMotion ? 0.45 : 1;
      fx.shakeTime = Math.max(fx.shakeTime, (0.05 + power * 0.06) * motionMult);
      fx.shakePower = Math.max(fx.shakePower, (1.2 + power * 2.6) * motionMult);
      fx.hitFlash = Math.max(fx.hitFlash, flash * motionMult);
      fx.hitStop = Math.max(fx.hitStop, stop * motionMult);
    }

    function registerRunBadge(id, label, rewardScore, rewardXp = 0) {
      const badges = state.progression.runBadges;
      if (!badges || badges[id]) return;
      badges[id] = true;
      state.score += rewardScore;
      if (rewardXp > 0) state.player.xp += rewardXp * xpMultiplier();
      pushKillfeed(`Badge: ${label}`, "#ffe694");
      showToast(`Badge unlocked: ${label}`);
    }

    function updateRunProgressionHooks() {
      if (state.match.bestStreak >= 8) {
        registerRunBadge("hunter", "Hot Streak", 150, 80);
      }
      if (state.player.tier >= 12) {
        registerRunBadge("survivor", "Sky Survivor", 170, 90);
      }
      if (state.player.tier >= 22 && state.score >= 2600) {
        registerRunBadge("apex", "Apex Pressure", 220, 120);
      }
    }

    function nearestLandmark(x) {
      let best = null;
      let bestDist = Number.POSITIVE_INFINITY;
      for (const lm of landmarkDefs) {
        const d = Math.abs(lm.x - x);
        if (d < bestDist) {
          bestDist = d;
          best = lm;
        }
      }
      return best ? { landmark: best, dist: bestDist } : null;
    }

    function botCountAround(x, radius, predicate = null) {
      let total = 0;
      for (const b of state.bots) {
        if (Math.abs(b.x - x) > radius) continue;
        if (predicate && !predicate(b)) continue;
        total++;
      }
      return total;
    }

    function spawnBotNearPlayer(kind = "prey", minDist = 220, maxDist = 760) {
      if (state.bots.length > BOT_TARGET + 24) return;
      const p = state.player;
      const sign = Math.random() < 0.5 ? -1 : 1;
      const x = clamp(
        p.x + sign * randomInt(minDist, maxDist),
        80,
        WORLD.width - 80
      );
      const zone = zoneTierBandAtX(x);
      let tier;
      if (kind === "prey") {
        const maxTier = Math.max(1, p.tier - 1);
        const minTier = Math.max(1, maxTier - 4, zone.min - 2);
        tier = randomInt(minTier, maxTier);
      } else if (kind === "threat") {
        if (p.tier <= 1) return;
        const minTier = Math.min(30, Math.max(2, p.tier + 1, zone.min));
        const maxTier = Math.min(30, Math.max(minTier, p.tier + 4, zone.max + 1));
        tier = randomInt(minTier, maxTier);
      } else {
        const minTier = Math.max(1, zone.min - 1);
        const maxTier = Math.max(minTier, zone.max + 1);
        tier = randomInt(minTier, Math.min(30, maxTier));
      }
      const fly = isAirTier(tier);
      const y = fly
        ? clamp(p.y + randomInt(-220, -40), 110, WORLD.height - 520)
        : Math.floor(groundY(x) - randomInt(0, 6));
      const elite = Math.random() < (state.worldEvent.type === "Frenzy Hunt" ? 0.14 : 0.05);
      state.bots.push({
        x,
        y,
        vx: (Math.random() - 0.5) * (fly ? 2.4 : 1.7),
        vy: (Math.random() - 0.5) * (fly ? 1.9 : 0.35),
        tier,
        size: (22 + tier * 0.9) * (elite ? 1.25 : 1),
        elite,
        kind: fly ? "air" : "ground",
        behaviorSeed: Math.random() * 10
      });
    }

    function spawnLandmarkResource(landmark) {
      if (!landmark) return;
      const x = clamp(landmark.x + randomInt(-220, 220), 80, WORLD.width - 80);
      const treeHeavy = landmark.type === "orchard" || landmark.type === "moon";
      const source = treeHeavy ? (Math.random() < 0.75 ? "tree" : "floor") : (Math.random() < 0.55 ? "tree" : "floor");
      const y = source === "tree" ? groundY(x) - randomInt(90, 170) : groundY(x) - randomInt(2, 8);
      const nutrition = Math.random() < (landmark.type === "grave" ? 0.45 : 0.72) ? "plant" : "meat";
      const item = source === "tree"
        ? (nutrition === "plant" ? (Math.random() < 0.5 ? "apple" : "banana") : "berry")
        : (nutrition === "plant" ? (Math.random() < 0.5 ? "carrot" : "pumpkin") : "mushroom");
      state.resources.push({
        x,
        y,
        size: source === "tree" ? randomInt(8, 12) : randomInt(9, 13),
        source,
        nutrition,
        item,
        xp: landmark.type === "moon" ? 34 : 22,
        score: landmark.type === "moon" ? 18 : 12
      });
    }

    function spawnLandmarkEncounter(landmark) {
      if (!landmark) return;
      const nearTier = clamp(state.player.tier + randomInt(-2, 2), 1, 30);
      const waves = landmark.type === "moon" ? 3 : 2;
      for (let i = 0; i < waves; i++) {
        const x = clamp(landmark.x + randomInt(-420, 420), 80, WORLD.width - 80);
        const isThreat = i === waves - 1 && nearTier >= 8;
        const tier = isThreat
          ? clamp(nearTier + randomInt(1, 3), 2, 30)
          : clamp(nearTier - randomInt(1, 4), 1, 30);
        const fly = isAirTier(tier);
        const y = fly
          ? clamp(groundY(x) - randomInt(120, 280), 100, WORLD.height - 520)
          : Math.floor(groundY(x) - randomInt(0, 6));
        state.bots.push({
          x,
          y,
          vx: (Math.random() - 0.5) * (fly ? 2.4 : 1.8),
          vy: (Math.random() - 0.5) * (fly ? 1.8 : 0.35),
          tier,
          size: (22 + tier * 0.9) * (isThreat ? 1.16 : 1),
          elite: isThreat && Math.random() < 0.45,
          kind: fly ? "air" : "ground",
          behaviorSeed: Math.random() * 10
        });
      }
    }

    function runSpawnDirector(dt) {
      const d = state.spawnDirector;
      d.preyPulse = Math.max(0, d.preyPulse - dt);
      d.threatPulse = Math.max(0, d.threatPulse - dt);
      d.landmarkPulse = Math.max(0, d.landmarkPulse - dt);
      if (state.bots.length > BOT_TARGET + 20) return;
      const p = state.player;

      let nearbyPrey = 0;
      let nearbyThreats = 0;
      for (const b of state.bots) {
        const dist = Math.hypot(b.x - p.x, b.y - p.y);
        if (dist > 1200) continue;
        if (canConsume(p.tier, b.tier)) nearbyPrey++;
        else if (canConsume(b.tier, p.tier)) nearbyThreats++;
      }

      const preyFloor = p.tier <= 3 ? 6 : 4;
      if (nearbyPrey < preyFloor && d.preyPulse <= 0) {
        const need = preyFloor - nearbyPrey;
        for (let i = 0; i < need; i++) spawnBotNearPlayer("prey", 180, 700);
        d.preyPulse = p.tier <= 3 ? 1.5 : 2.2;
      }
      if (p.tier >= 6 && nearbyThreats < 1 && d.threatPulse <= 0) {
        spawnBotNearPlayer("threat", 680, 1380);
        d.threatPulse = 6.4;
      }
      if (d.landmarkPulse <= 0) {
        const near = nearestLandmark(p.x);
        if (near && near.dist < 2200) {
          const lm = near.landmark;
          const localFood = state.resources.filter((r) => Math.abs(r.x - lm.x) < 520).length;
          if (localFood < 6) {
            for (let i = 0; i < 4; i++) spawnLandmarkResource(lm);
          }
          const localCreatures = botCountAround(lm.x, 700);
          if (localCreatures < 4) {
            spawnLandmarkEncounter(lm);
          }
        }
        d.landmarkPulse = 9.5;
      }
    }

    function resetRunState(resetWorld = false) {
      const p = state.player;
      const sv = state.survival;
      p.x = 180;
      p.y = groundY(180);
      p.vx = 0;
      p.vy = 0;
      p.size = entitySizeForTier(1);
      p.tier = 1;
      p.xp = 0;
      p.xpToNext = 50;
      p.facing = 1;
      p.moonCombo = 0;
      p.grounded = true;
      p.coyoteTimer = 0;
      p.jumpBufferTimer = 0;
      p.hp = 100;
      p.invulnTimer = 0;
      p.flapCd = 0;
      p.attackCd = 0;
      p.tunnelCd = 0;

      sv.energy = 100;
      sv.hydration = 100;
      sv.oxygen = 100;
      sv.tickDamageCd = 0;

      state.score = 0;
      state.foodStats = { tree: 0, floor: 0 };
      state.quest = defaultQuestState();
      state.objective = defaultObjectiveState();
      state.objectiveStats.difficulty = 0;
      state.objectiveStats.lastDuration = 0;
      state.objectiveStats.completed = 0;
      state.loot.relics = 0;
      state.loot.shards = 0;
      state.loot.cores = 0;
      state.loot.upgrades.aero = 0;
      state.loot.upgrades.guard = 0;
      state.loot.upgrades.moon = 0;
      state.spawnDirector.preyPulse = 0;
      state.spawnDirector.threatPulse = 0;
      state.spawnDirector.landmarkPulse = 0;
      state.fx.hitStop = 0;
      state.fx.hitFlash = 0;
      state.fx.shakeTime = 0;
      state.fx.shakePower = 0;
      state.death.lastX = null;
      state.death.lastY = null;
      state.death.reason = "";
      state.death.tier = 1;
      state.death.streakLost = 0;
      state.death.revengeActive = false;
      state.progression.runBadges = {
        hunter: false,
        survivor: false,
        apex: false,
        boss: false
      };
      state.match.spawnShield = 0;
      state.match.respawnTimer = 0;
      state.match.deathReason = "";
      state.match.streak = 0;
      state.match.bountyScore = 600;
      state.match.bountyStep = 600;
      state.match.killfeed.length = 0;

      if (resetWorld) {
        state.bots.length = 0;
        state.resources.length = 0;
        state.bosses.length = 0;
        state.bossSystem.cooldown = 8;
        for (let i = 0; i < BOT_TARGET; i++) spawnBot(i % 3 === 0 ? "air" : "ground");
        for (let i = 0; i < FOOD_TARGET; i++) spawnResource(i % 2 === 0 ? "tree" : "floor");
      }
      setNextObjective("silent");

      syncCamera(1 / 60);
    }

    function syncAccountProgressFromRun() {
      const a = state.account;
      const p = state.player;
      if (p.tier > a.tier) {
        a.tier = p.tier;
        a.xp = p.xp;
        a.xpToNext = p.xpToNext;
      } else if (p.tier === a.tier && p.xp > a.xp) {
        a.xp = p.xp;
        a.xpToNext = Math.max(a.xpToNext || 50, p.xpToNext);
      }
      a.score = Math.max(a.score || 0, state.score || 0);
      a.lifetimeXp = Math.max(a.lifetimeXp || 0, estimatedLifetimeXp(a.tier, a.xp));
    }

    function updateAuthUi() {
      const loggedIn = !!state.signedUp;
      ui.signupBtn.classList.toggle("hidden-auth", loggedIn);
      ui.googleBtn.classList.toggle("hidden-auth", loggedIn);
      ui.googleRender.classList.toggle("hidden-auth", loggedIn);
      ui.profileCard.classList.toggle("hidden-auth", !loggedIn);
      ui.playerName.readOnly = loggedIn;
      ui.playerEmail.readOnly = loggedIn;
      updateSettingsSyncHint();
    }

    function updateProfileCard() {
      if (!state.signedUp) {
        ui.profileMeta.textContent = "No active profile.";
        return;
      }
      const a = state.account;
      const lifetimeXp = Math.max(a.lifetimeXp || 0, estimatedLifetimeXp(a.tier, a.xp));
      const boost = state.subscribed ? "Active (+60%)" : "Free";
      ui.profileMeta.textContent =
        `Provider: ${state.authProvider || "local"} | ` +
        `Email: ${ui.playerEmail.value.trim()} | ` +
        `Best Tier: ${a.tier} | Best XP: ${Math.floor(a.xp)}/${a.xpToNext} | ` +
        `Lifetime XP ~${Math.floor(lifetimeXp)} | Best Score: ${Math.floor(a.score)} | Boost: ${boost}`;
    }

    function updateProgressHint() {
      if (!state.signedUp) {
        ui.progressHint.textContent = "Sign in to save account XP. Every new match starts at Tier 1.";
        updateSettingsSyncHint();
        updateProfileCard();
        return;
      }
      const a = state.account;
      const lifetimeXp = Math.max(a.lifetimeXp || 0, estimatedLifetimeXp(a.tier, a.xp));
      ui.progressHint.textContent = `Account progress saved: Best Tier ${a.tier}, Best XP ${Math.floor(a.xp)}/${a.xpToNext}, Lifetime XP ~${Math.floor(lifetimeXp)}. New matches start at Tier 1.`;
      updateSettingsSyncHint();
      updateProfileCard();
    }

    function loadLocalSettings() {
      try {
        const raw = localStorage.getItem("skybeast_settings_v1");
        if (!raw) return;
        const saved = JSON.parse(raw);
        if (saved && typeof saved === "object") {
          if (["medium", "high", "ultra"].includes(saved.quality)) {
            state.quality = saved.quality;
          }
          if (typeof saved.reduceMotion === "boolean") {
            state.settings.reduceMotion = saved.reduceMotion;
          }
          if (typeof saved.showMiniMap === "boolean") {
            state.showMiniMap = saved.showMiniMap;
          }
          if (typeof saved.advancedHud === "boolean") {
            state.settings.advancedHud = saved.advancedHud;
          }
          if (typeof saved.autoSave === "boolean") {
            state.settings.autoSave = saved.autoSave;
          }
          if (typeof saved.autoPerformance === "boolean") {
            state.settings.autoPerformance = saved.autoPerformance;
          }
          if (typeof saved.highContrast === "boolean") {
            state.settings.highContrast = saved.highContrast;
          }
          if (typeof saved.colorblindSafe === "boolean") {
            state.settings.colorblindSafe = saved.colorblindSafe;
          }
          const localTextScale = numberOr(saved.textScale, state.settings.textScale);
          if ([1, 1.15, 1.3].includes(localTextScale)) {
            state.settings.textScale = localTextScale;
          }
          if (saved.audio && typeof saved.audio === "object") {
            const a = saved.audio;
            state.audioSettings.masterVolume = clamp(numberOr(a.masterVolume, state.audioSettings.masterVolume), 0, 1);
            state.audioSettings.musicVolume = clamp(numberOr(a.musicVolume, state.audioSettings.musicVolume), 0, 1);
            state.audioSettings.sfxVolume = clamp(numberOr(a.sfxVolume, state.audioSettings.sfxVolume), 0, 1);
            state.audioSettings.muteMaster = !!a.muteMaster;
            state.audioSettings.muteMusic = !!a.muteMusic;
            state.audioSettings.muteSfx = !!a.muteSfx;
          }
          if (saved.controls && typeof saved.controls === "object") {
            for (const key of Object.keys(DEFAULT_CONTROL_BINDINGS)) {
              if (typeof saved.controls[key] === "string" && saved.controls[key]) {
                state.controls[key] = saved.controls[key];
              }
            }
          }
        }
      } catch (_) {
        // ignore corrupted local settings
      }
      if (!AUDIO_ENABLED) hardMuteAudioSettings();
    }

    function exportSettingsPayload() {
      return {
        version: SETTINGS_SCHEMA_VERSION,
        quality: state.quality,
        reduceMotion: state.settings.reduceMotion,
        showMiniMap: state.showMiniMap,
        advancedHud: state.settings.advancedHud,
        autoSave: state.settings.autoSave,
        autoPerformance: state.settings.autoPerformance,
        highContrast: state.settings.highContrast,
        colorblindSafe: state.settings.colorblindSafe,
        textScale: state.settings.textScale,
        audio: {
          masterVolume: state.audioSettings.masterVolume,
          musicVolume: state.audioSettings.musicVolume,
          sfxVolume: state.audioSettings.sfxVolume,
          muteMaster: state.audioSettings.muteMaster,
          muteMusic: state.audioSettings.muteMusic,
          muteSfx: state.audioSettings.muteSfx
        },
        controls: { ...state.controls }
      };
    }

    function isSettingsShape(value) {
      if (!value || typeof value !== "object") return false;
      if (typeof value.quality === "string") return true;
      if (value.audio && typeof value.audio === "object") return true;
      if (value.controls && typeof value.controls === "object") return true;
      return false;
    }

    function extractImportedSettings(raw) {
      if (!raw || typeof raw !== "object") {
        throw new Error("Invalid JSON object");
      }
      if (raw.settings && typeof raw.settings === "object") {
        return raw.settings;
      }
      if (isSettingsShape(raw)) {
        return raw;
      }
      throw new Error("No settings payload found");
    }

    function exportSettingsToFile() {
      const envelope = {
        app: SETTINGS_EXPORT_APP,
        version: SETTINGS_SCHEMA_VERSION,
        exportedAt: new Date().toISOString(),
        settings: exportSettingsPayload()
      };
      const json = JSON.stringify(envelope, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      const a = document.createElement("a");
      a.href = url;
      a.download = `skybeast-settings-${stamp}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 0);
      showToast("Settings exported");
    }

    async function importSettingsFromFile(file) {
      if (!file) return;
      let raw;
      try {
        const text = await file.text();
        raw = JSON.parse(text);
      } catch (_) {
        showToast("Import failed: invalid JSON file");
        return;
      }
      let importedSettings;
      try {
        importedSettings = extractImportedSettings(raw);
      } catch (_) {
        showToast("Import failed: settings payload not found");
        return;
      }
      applyRemoteSettings(importedSettings);
      applySettingsFromUi(true, true);
      showToast("Settings imported");
    }

    function applySettingsFromUi(save = true, syncServer = false) {
      state.quality = ui.qualitySelect.value;
      state.settings.autoPerformance = !!ui.autoPerfToggle.checked;
      state.settings.reduceMotion = !!ui.reduceMotionToggle.checked;
      state.showMiniMap = !!ui.minimapToggle.checked;
      state.settings.advancedHud = !!ui.advancedHudToggle.checked;
      state.settings.autoSave = !!ui.autosaveToggle.checked;
      state.settings.highContrast = !!ui.highContrastToggle.checked;
      state.settings.colorblindSafe = !!ui.colorblindToggle.checked;
      state.settings.textScale = Number(ui.textScaleSelect.value) || 1;
      if (AUDIO_ENABLED) {
        state.audioSettings.muteMaster = !!ui.muteMasterToggle.checked;
        state.audioSettings.muteMusic = !!ui.muteMusicToggle.checked;
        state.audioSettings.muteSfx = !!ui.muteSfxToggle.checked;
        state.audioSettings.masterVolume = clamp(Number(ui.masterVolumeSlider.value) / 100, 0, 1);
        state.audioSettings.musicVolume = clamp(Number(ui.musicVolumeSlider.value) / 100, 0, 1);
        state.audioSettings.sfxVolume = clamp(Number(ui.sfxVolumeSlider.value) / 100, 0, 1);
      } else {
        hardMuteAudioSettings();
      }
      applyAccessibilitySettings();
      applyAudioSettings();
      syncVolumeLabels();
      syncPresetButtons();
      renderControlBindingsUi();
      if (save) {
        localStorage.setItem("skybeast_settings_v1", JSON.stringify(exportSettingsPayload()));
      }
      if (syncServer && state.signedUp) {
        saveProgress();
      }
    }

    function syncSettingsUi() {
      ui.qualitySelect.value = state.quality;
      ui.autoPerfToggle.checked = state.settings.autoPerformance;
      ui.reduceMotionToggle.checked = state.settings.reduceMotion;
      ui.minimapToggle.checked = state.showMiniMap;
      ui.advancedHudToggle.checked = state.settings.advancedHud;
      ui.autosaveToggle.checked = state.settings.autoSave;
      ui.highContrastToggle.checked = state.settings.highContrast;
      ui.colorblindToggle.checked = state.settings.colorblindSafe;
      if (!AUDIO_ENABLED) hardMuteAudioSettings();
      ui.textScaleSelect.value = String(state.settings.textScale);
      ui.muteMasterToggle.checked = state.audioSettings.muteMaster;
      ui.muteMusicToggle.checked = state.audioSettings.muteMusic;
      ui.muteSfxToggle.checked = state.audioSettings.muteSfx;
      ui.masterVolumeSlider.value = String(Math.round(state.audioSettings.masterVolume * 100));
      ui.musicVolumeSlider.value = String(Math.round(state.audioSettings.musicVolume * 100));
      ui.sfxVolumeSlider.value = String(Math.round(state.audioSettings.sfxVolume * 100));
      applyAccessibilitySettings();
      syncVolumeLabels();
      syncPresetButtons();
      renderControlBindingsUi();
    }

    function applyPreset(name, syncServer = true) {
      if (name === "low") {
        state.quality = "medium";
        state.settings.reduceMotion = true;
        state.settings.advancedHud = false;
        state.settings.autoPerformance = true;
      } else if (name === "balanced") {
        state.quality = "high";
        state.settings.reduceMotion = false;
        state.settings.advancedHud = true;
        state.settings.autoPerformance = true;
      } else {
        state.quality = "ultra";
        state.settings.reduceMotion = false;
        state.settings.advancedHud = true;
        state.settings.autoPerformance = false;
      }
      syncSettingsUi();
      applySettingsFromUi(true, syncServer);
    }

    function resetControlBindingsToDefault(syncServer = true) {
      state.controls = { ...DEFAULT_CONTROL_BINDINGS };
      syncSettingsUi();
      applySettingsFromUi(true, syncServer);
    }

    function setControlBinding(action, code, syncServer = true) {
      if (!action || !(action in DEFAULT_CONTROL_BINDINGS)) return;
      if (!code || NON_REMAPPABLE_CODES.has(code)) {
        showToast("That key is reserved");
        return;
      }
      const previous = actionCode(action);
      for (const key of Object.keys(state.controls)) {
        if (key !== action && state.controls[key] === code) {
          state.controls[key] = previous;
          break;
        }
      }
      state.controls[action] = code;
      syncSettingsUi();
      applySettingsFromUi(true, syncServer);
      showToast(`${CONTROL_LABELS[action]}: ${readableKey(code)}`);
    }

    function snapshotCurrentSettings() {
      return {
        quality: state.quality,
        showMiniMap: state.showMiniMap,
        settings: {
          reduceMotion: state.settings.reduceMotion,
          advancedHud: state.settings.advancedHud,
          autoSave: state.settings.autoSave,
          autoPerformance: state.settings.autoPerformance,
          highContrast: state.settings.highContrast,
          colorblindSafe: state.settings.colorblindSafe,
          textScale: state.settings.textScale
        },
        audioSettings: { ...state.audioSettings },
        controls: { ...state.controls }
      };
    }

    function applySettingsSnapshot(snapshot, syncServer = true) {
      if (!snapshot) return;
      state.quality = ["medium", "high", "ultra"].includes(snapshot.quality) ? snapshot.quality : "ultra";
      state.showMiniMap = !!snapshot.showMiniMap;
      state.settings.reduceMotion = !!snapshot.settings?.reduceMotion;
      state.settings.advancedHud = !!snapshot.settings?.advancedHud;
      state.settings.autoSave = !!snapshot.settings?.autoSave;
      state.settings.autoPerformance = !!snapshot.settings?.autoPerformance;
      state.settings.highContrast = !!snapshot.settings?.highContrast;
      state.settings.colorblindSafe = !!snapshot.settings?.colorblindSafe;
      const snapTextScale = numberOr(snapshot.settings?.textScale, 1);
      state.settings.textScale = [1, 1.15, 1.3].includes(snapTextScale)
        ? snapTextScale
        : 1;
      state.audioSettings = {
        masterVolume: clamp(numberOr(snapshot.audioSettings?.masterVolume, DEFAULT_AUDIO_SETTINGS.masterVolume), 0, 1),
        musicVolume: clamp(numberOr(snapshot.audioSettings?.musicVolume, DEFAULT_AUDIO_SETTINGS.musicVolume), 0, 1),
        sfxVolume: clamp(numberOr(snapshot.audioSettings?.sfxVolume, DEFAULT_AUDIO_SETTINGS.sfxVolume), 0, 1),
        muteMaster: !!snapshot.audioSettings?.muteMaster,
        muteMusic: !!snapshot.audioSettings?.muteMusic,
        muteSfx: !!snapshot.audioSettings?.muteSfx
      };
      if (!AUDIO_ENABLED) hardMuteAudioSettings();
      state.controls = { ...DEFAULT_CONTROL_BINDINGS, ...(snapshot.controls || {}) };
      syncSettingsUi();
      applySettingsFromUi(true, syncServer);
    }

    function resetSettingsToDefault(syncServer = true) {
      state.quality = DEFAULT_LOCAL_SETTINGS.quality;
      state.settings.reduceMotion = DEFAULT_LOCAL_SETTINGS.reduceMotion;
      state.showMiniMap = DEFAULT_LOCAL_SETTINGS.showMiniMap;
      state.settings.advancedHud = DEFAULT_LOCAL_SETTINGS.advancedHud;
      state.settings.autoSave = DEFAULT_LOCAL_SETTINGS.autoSave;
      state.settings.autoPerformance = DEFAULT_LOCAL_SETTINGS.autoPerformance;
      state.settings.highContrast = DEFAULT_LOCAL_SETTINGS.highContrast;
      state.settings.colorblindSafe = DEFAULT_LOCAL_SETTINGS.colorblindSafe;
      state.settings.textScale = DEFAULT_LOCAL_SETTINGS.textScale;
      state.audioSettings = { ...DEFAULT_AUDIO_SETTINGS };
      if (!AUDIO_ENABLED) hardMuteAudioSettings();
      state.controls = { ...DEFAULT_CONTROL_BINDINGS };
      syncSettingsUi();
      applySettingsFromUi(true, syncServer);
    }

    function ensureAudioEngine() {
      if (!AUDIO_ENABLED) return;
      if (state.audio.ready) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;

      const ctxAudio = new AudioCtx();
      const masterGain = ctxAudio.createGain();
      const musicGain = ctxAudio.createGain();
      const sfxGain = ctxAudio.createGain();
      const musicFilter = ctxAudio.createBiquadFilter();
      const musicOscA = ctxAudio.createOscillator();
      const musicOscB = ctxAudio.createOscillator();
      const musicLfo = ctxAudio.createOscillator();
      const musicLfoGain = ctxAudio.createGain();

      musicOscA.type = "sine";
      musicOscA.frequency.value = 124;
      musicOscB.type = "triangle";
      musicOscB.frequency.value = 182;
      musicLfo.type = "sine";
      musicLfo.frequency.value = 0.08;
      musicLfoGain.gain.value = 7;
      musicFilter.type = "lowpass";
      musicFilter.frequency.value = 760;
      masterGain.gain.value = 0;
      musicGain.gain.value = 0;
      sfxGain.gain.value = 0;

      musicLfo.connect(musicLfoGain);
      musicLfoGain.connect(musicOscB.frequency);
      musicOscA.connect(musicFilter);
      musicOscB.connect(musicFilter);
      musicFilter.connect(musicGain);
      musicGain.connect(masterGain);
      sfxGain.connect(masterGain);
      masterGain.connect(ctxAudio.destination);

      musicOscA.start();
      musicOscB.start();
      musicLfo.start();

      state.audio.ready = true;
      state.audio.ctx = ctxAudio;
      state.audio.masterGain = masterGain;
      state.audio.musicGain = musicGain;
      state.audio.sfxGain = sfxGain;
      state.audio.musicOscA = musicOscA;
      state.audio.musicOscB = musicOscB;
      state.audio.musicLfo = musicLfo;
      state.audio.musicLfoGain = musicLfoGain;
      applyAudioSettings();
    }

    function unlockAudio() {
      if (!AUDIO_ENABLED) return;
      ensureAudioEngine();
      if (!state.audio.ctx) return;
      if (state.audio.ctx.state === "suspended") {
        state.audio.ctx.resume().catch(() => {});
      }
    }

    function applyAudioSettings() {
      if (!AUDIO_ENABLED) {
        hardMuteAudioSettings();
        return;
      }
      if (!state.audio.ready || !state.audio.ctx) return;
      const now = state.audio.ctx.currentTime;
      const masterTarget = state.audioSettings.muteMaster ? 0 : clamp(state.audioSettings.masterVolume, 0, 1);
      const musicTarget = state.audioSettings.muteMusic ? 0 : clamp(state.audioSettings.musicVolume, 0, 1) * 0.35;
      const sfxTarget = state.audioSettings.muteSfx ? 0 : clamp(state.audioSettings.sfxVolume, 0, 1) * 0.95;

      state.audio.masterGain.gain.cancelScheduledValues(now);
      state.audio.musicGain.gain.cancelScheduledValues(now);
      state.audio.sfxGain.gain.cancelScheduledValues(now);
      state.audio.masterGain.gain.linearRampToValueAtTime(masterTarget, now + 0.05);
      state.audio.musicGain.gain.linearRampToValueAtTime(musicTarget, now + 0.08);
      state.audio.sfxGain.gain.linearRampToValueAtTime(sfxTarget, now + 0.04);
    }

    function playSfx(kind = "tap") {
      if (!AUDIO_ENABLED) return;
      if (!state.audio.ready || !state.audio.ctx || state.audio.ctx.state !== "running") return;
      if (state.audioSettings.muteMaster || state.audioSettings.muteSfx) return;
      if ((state.audioSettings.sfxVolume || 0) <= 0.01) return;

      const presets = {
        tap: { start: 430, end: 300, dur: 0.09, type: "triangle" },
        start: { start: 310, end: 520, dur: 0.16, type: "triangle" },
        level: { start: 540, end: 760, dur: 0.2, type: "sine" },
        dash: { start: 250, end: 150, dur: 0.12, type: "sawtooth" },
        sonic: { start: 660, end: 300, dur: 0.16, type: "square" },
        regen: { start: 380, end: 520, dur: 0.16, type: "triangle" },
        slash: { start: 510, end: 240, dur: 0.12, type: "sawtooth" }
      };
      const p = presets[kind] || presets.tap;
      const now = state.audio.ctx.currentTime;
      const osc = state.audio.ctx.createOscillator();
      const gain = state.audio.ctx.createGain();
      const filter = state.audio.ctx.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.value = Math.max(120, p.start * 1.35);
      filter.Q.value = 1.2;
      osc.type = p.type;
      osc.frequency.setValueAtTime(p.start, now);
      osc.frequency.exponentialRampToValueAtTime(Math.max(80, p.end), now + p.dur);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.28, now + 0.012);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + p.dur);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(state.audio.sfxGain);
      osc.start(now);
      osc.stop(now + p.dur + 0.03);
    }

    function showToast(text, options = {}) {
      if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
      }
      ui.toast.innerHTML = "";
      ui.toast.classList.remove("actionable");

      const textSpan = document.createElement("span");
      textSpan.textContent = text;
      ui.toast.appendChild(textSpan);

      if (options.actionLabel && typeof options.onAction === "function") {
        const actionBtn = document.createElement("button");
        actionBtn.type = "button";
        actionBtn.className = "toast-action";
        actionBtn.textContent = options.actionLabel;
        actionBtn.addEventListener("click", () => {
          ui.toast.classList.remove("show");
          ui.toast.classList.remove("actionable");
          options.onAction();
        }, { once: true });
        ui.toast.appendChild(actionBtn);
        ui.toast.classList.add("actionable");
      }

      ui.toast.classList.add("show");
      toastTimer = setTimeout(() => {
        ui.toast.classList.remove("show");
        ui.toast.classList.remove("actionable");
      }, Math.max(900, options.duration || 1100));
    }

    function addCombatText(x, y, text, color = "#ffd973", size = 14) {
      state.combatTexts.push({
        x,
        y,
        text,
        color,
        size,
        vx: (Math.random() - 0.5) * 14,
        vy: -56 - Math.random() * 14,
        life: 0.9,
        maxLife: 0.9
      });
      if (state.combatTexts.length > 90) {
        state.combatTexts.splice(0, state.combatTexts.length - 90);
      }
    }

    function updateCombatTexts(dt) {
      for (let i = state.combatTexts.length - 1; i >= 0; i--) {
        const t = state.combatTexts[i];
        t.life -= dt;
        t.x += t.vx * dt;
        t.y += t.vy * dt;
        t.vy += 40 * dt;
        if (t.life <= 0) state.combatTexts.splice(i, 1);
      }
    }

    function fmtCd(value) {
      return value <= 0 ? "Ready" : `${value.toFixed(1)}s`;
    }

    async function apiFetch(path, options = {}) {
      try {
        const res = await fetch(path, options);
        if (!res.ok) return null;
        return await res.json();
      } catch (_) {
        return null;
      }
    }

    function applyRemoteSettings(remote) {
      if (!remote || typeof remote !== "object") return;
      const snapshot = snapshotCurrentSettings();
      if (["medium", "high", "ultra"].includes(remote.quality)) {
        snapshot.quality = remote.quality;
      }
      if (typeof remote.showMiniMap === "boolean") snapshot.showMiniMap = remote.showMiniMap;
      if (typeof remote.reduceMotion === "boolean") snapshot.settings.reduceMotion = remote.reduceMotion;
      if (typeof remote.advancedHud === "boolean") snapshot.settings.advancedHud = remote.advancedHud;
      if (typeof remote.autoSave === "boolean") snapshot.settings.autoSave = remote.autoSave;
      if (typeof remote.autoPerformance === "boolean") snapshot.settings.autoPerformance = remote.autoPerformance;
      if (typeof remote.highContrast === "boolean") snapshot.settings.highContrast = remote.highContrast;
      if (typeof remote.colorblindSafe === "boolean") snapshot.settings.colorblindSafe = remote.colorblindSafe;
      const remoteTextScale = numberOr(remote.textScale, snapshot.settings.textScale);
      if ([1, 1.15, 1.3].includes(remoteTextScale)) {
        snapshot.settings.textScale = remoteTextScale;
      }
      if (remote.audio && typeof remote.audio === "object") {
        snapshot.audioSettings = {
          masterVolume: clamp(numberOr(remote.audio.masterVolume, snapshot.audioSettings.masterVolume), 0, 1),
          musicVolume: clamp(numberOr(remote.audio.musicVolume, snapshot.audioSettings.musicVolume), 0, 1),
          sfxVolume: clamp(numberOr(remote.audio.sfxVolume, snapshot.audioSettings.sfxVolume), 0, 1),
          muteMaster: !!remote.audio.muteMaster,
          muteMusic: !!remote.audio.muteMusic,
          muteSfx: !!remote.audio.muteSfx
        };
      }
      if (!AUDIO_ENABLED) hardMuteAudioSettings();
      if (remote.controls && typeof remote.controls === "object") {
        snapshot.controls = { ...DEFAULT_CONTROL_BINDINGS, ...remote.controls };
      }
      applySettingsSnapshot(snapshot, false);
    }

    async function saveProgress() {
      if (!state.signedUp) return;
      syncAccountProgressFromRun();
      const a = state.account;
      const payload = {
        email: ui.playerEmail.value.trim(),
        name: ui.playerName.value.trim(),
        tier: a.tier,
        xp: a.xp,
        xpToNext: a.xpToNext,
        score: a.score,
        subscribed: state.subscribed,
        foodStats: state.foodStats,
        quest: state.quest,
        settings: exportSettingsPayload()
      };
      const data = await apiFetch("/api/save-progress", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (data && data.ok) {
        state.net.leaderboard = data.leaderboard || [];
      } else {
        const local = JSON.parse(localStorage.getItem("skybeast_lb") || "[]");
        local.push(payload);
        local.sort((a, b) => b.score - a.score);
        localStorage.setItem("skybeast_lb", JSON.stringify(local.slice(0, 5)));
        state.net.leaderboard = local.slice(0, 5);
      }
    }

    async function loadProgressAndLeaderboard() {
      if (!state.signedUp) return;
      const data = await apiFetch("/api/progress");
      if (data && data.progress) {
        const a = state.account;
        a.tier = Math.max(1, Math.min(30, data.progress.tier || 1));
        a.xp = Math.max(0, data.progress.xp || 0);
        a.xpToNext = Math.max(50, data.progress.xpToNext || 50);
        a.score = Math.max(0, data.progress.score || 0);
        a.lifetimeXp = Math.max(a.lifetimeXp || 0, estimatedLifetimeXp(a.tier, a.xp));
        state.subscribed = !!data.progress.subscribed;
        ui.subBtn.textContent = state.subscribed
          ? "Subscription Active (+60%)"
          : "Activate Subscription Boost (+60%)";
        applyRemoteSettings(data.progress.settings || null);
      }
      state.net.leaderboard = (data && data.leaderboard) || JSON.parse(localStorage.getItem("skybeast_lb") || "[]");
      updateProgressHint();
    }

    function setLoggedInUser({ name, email, provider }) {
      ui.playerName.value = name || ui.playerName.value;
      ui.playerEmail.value = email || ui.playerEmail.value;
      state.signedUp = true;
      state.authProvider = provider || "local";
      ui.accountState.textContent = `Signed in (${state.authProvider}) as ${ui.playerName.value} (${ui.playerEmail.value}). New matches start at Tier 1.`;
      updateAuthUi();
      updateProgressHint();
    }

    function setLoggedOutUser() {
      state.signedUp = false;
      state.authProvider = null;
      state.account = {
        tier: 1,
        xp: 0,
        xpToNext: 50,
        score: 0,
        lifetimeXp: 0
      };
      ui.accountState.textContent = "Not signed in";
      ui.playerName.readOnly = false;
      ui.playerEmail.readOnly = false;
      updateAuthUi();
      updateProgressHint();
    }

    async function restoreSession() {
      const data = await apiFetch("/api/session");
      if (!data || !data.ok || !data.user) return;
      setLoggedInUser({
        name: data.user.name || "Player",
        email: data.user.email,
        provider: data.user.authProvider || "local"
      });
      await loadProgressAndLeaderboard();
    }

    async function loadAuthConfig() {
      const data = await apiFetch("/api/auth-config");
      if (!data || !data.ok) return;
      state.googleClientId = (data.googleClientId || "").trim();
    }

    function hasGoogleSdk() {
      return !!(window.google && window.google.accounts && window.google.accounts.id);
    }

    function getGoogleClientId() {
      return (localStorage.getItem("google_client_id") || "").trim() || state.googleClientId;
    }

    function ensureGoogleSdk(timeoutMs = 12000) {
      if (hasGoogleSdk()) return Promise.resolve(true);
      if (state.googleSdkPromise) return state.googleSdkPromise;

      ui.googleHint.textContent = "Loading Google SDK...";
      state.googleSdkPromise = new Promise((resolve) => {
        const existing = Array.from(document.scripts)
          .find((s) => (s.src || "").includes("accounts.google.com/gsi/client"));
        const script = existing || document.createElement("script");
        let done = false;

        const finish = (ok) => {
          if (done) return;
          done = true;
          state.googleSdkPromise = null;
          resolve(ok);
        };

        const timer = setTimeout(() => {
          ui.googleHint.textContent = "Google SDK blocked/timed out. Allow accounts.google.com in your blocker settings.";
          finish(false);
        }, timeoutMs);

        const onLoad = () => {
          clearTimeout(timer);
          finish(hasGoogleSdk());
        };
        const onError = () => {
          clearTimeout(timer);
          ui.googleHint.textContent = "Failed loading Google SDK. Disable strict privacy/ad blocker and reload.";
          finish(false);
        };

        script.addEventListener("load", onLoad, { once: true });
        script.addEventListener("error", onError, { once: true });

        if (!existing) {
          script.src = "https://accounts.google.com/gsi/client";
          script.async = true;
          script.defer = true;
          document.head.appendChild(script);
        }
      });

      return state.googleSdkPromise;
    }

    function initGoogleSignIn() {
      if (state.googleInitialized) return true;
      const clientId = getGoogleClientId();
      if (!clientId) {
        ui.googleHint.textContent = "Missing Google Client ID. Set GOOGLE_CLIENT_ID in .env and restart server.";
        return false;
      }
      if (!hasGoogleSdk()) {
        ui.googleHint.textContent = "Google SDK is not available yet.";
        return false;
      }
      ui.googleHint.textContent = "Google sign-in enabled.";
      window.google.accounts.id.initialize({
        client_id: clientId,
        auto_select: false,
        callback: async (response) => {
          const data = await apiFetch("/api/google-login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ credential: response.credential })
          });
          if (!data || !data.ok || !data.user) {
            showToast("Google login failed");
            return;
          }
          setLoggedInUser({
            name: data.user.name,
            email: data.user.email,
            provider: "google"
          });
          state.net.leaderboard = data.leaderboard || state.net.leaderboard;
          await loadProgressAndLeaderboard();
          if (state.gameStarted && (!state.net.socket || state.net.socket.readyState > 1)) {
            connectMultiplayer();
          }
          await saveProgress();
          showToast("Google login success");
        }
      });
      if (!state.googleButtonRendered && ui.googleRender) {
        ui.googleRender.innerHTML = "";
        window.google.accounts.id.renderButton(ui.googleRender, {
          type: "standard",
          theme: "outline",
          size: "large",
          text: "signin_with",
          shape: "pill",
          width: 280
        });
        state.googleButtonRendered = true;
      }
      state.googleInitialized = true;
      return true;
    }

    async function waitForGoogleSdk(maxMs = 12000) {
      const ok = await ensureGoogleSdk(maxMs);
      if (!ok) return false;
      return initGoogleSignIn();
    }

    function connectMultiplayer() {
      const protocol = location.protocol === "https:" ? "wss" : "ws";
      const email = encodeURIComponent(ui.playerEmail.value.trim() || `guest_${Math.random().toString(36).slice(2, 7)}`);
      const name = encodeURIComponent(ui.playerName.value.trim() || "Guest");
      const ws = new WebSocket(`${protocol}://${location.host}/ws?name=${name}&email=${email}`);
      state.net.socket = ws;

      ws.addEventListener("open", () => {
        state.net.connected = true;
      });
      ws.addEventListener("close", () => {
        state.net.connected = false;
        state.net.remotePlayers = {};
      });
      ws.addEventListener("message", (ev) => {
        let msg;
        try {
          msg = JSON.parse(ev.data);
        } catch (_) {
          return;
        }
        if (msg.type === "welcome") {
          state.net.id = msg.id;
        }
        if (msg.type === "presence") {
          state.net.onlineCount = msg.count || 1;
        }
        if (msg.type === "state" && msg.players) {
          state.net.remotePlayers = msg.players;
        }
      });
    }

    function registerEat(bot, bonusXp = 0) {
      const p = state.player;
      const sv = state.survival;
      const perks = tierPerkProfile(p.tier);
      const eliteBonus = bot.elite ? 1.9 : 1;
      const scoreGain = Math.floor((10 + bot.tier) * eliteBonus);
      const xpGain = ((14 + bot.tier * 1.8) * eliteBonus + bonusXp) * xpMultiplier() * perks.forageBoost;
      state.score += scoreGain;
      p.xp += xpGain;
      sv.energy = clamp(sv.energy + (7 + bot.tier * 0.18) * perks.sustainMult, 0, 100);
      sv.hydration = clamp(sv.hydration + (4 + bot.tier * 0.1) * perks.sustainMult, 0, 100);
      if (p.tier >= 24) {
        p.hp = Math.min(100, p.hp + (bot.elite ? 5 : 2));
      }
      addCombatText(bot.x, bot.y - bot.size * 0.4, `+${Math.floor(xpGain)} XP`, "#ffe28a", 13);
      applyImpactFx(bot.elite ? 0.78 : 0.46, bot.elite ? 0.16 : 0.09, bot.elite ? 0.012 : 0.006);
      state.match.streak += 1;
      state.match.bestStreak = Math.max(state.match.bestStreak, state.match.streak);
      if (state.match.streak % 5 === 0) {
        state.score += 40;
        pushKillfeed(`Streak x${state.match.streak} (+40 score)`, "#ffd88f");
      }

      const missionType = state.biomeMission.type;
      if (missionType === "elite_bots" && bot.elite) addBiomeMissionProgress(1);
      if (missionType === "air_bots" && bot.kind === "air") addBiomeMissionProgress(1);
      if (missionType === "ground_bots" && bot.kind === "ground") addBiomeMissionProgress(1);
      addObjectiveProgress("eat_any", 1);
      if (bot.kind === "air") addObjectiveProgress("eat_air", 1);
      if (bot.elite) addObjectiveProgress("eat_elite", 1);

      state.quest.progress += bot.elite ? 2 : 1;
      if (state.quest.progress >= state.quest.target) {
        state.quest.progress -= state.quest.target;
        p.xp += state.quest.rewardXp;
        state.score += state.quest.rewardScore;
        state.quest.target = Math.min(36, state.quest.target + 3);
        state.quest.rewardXp = Math.floor(state.quest.rewardXp * 1.12 + 30);
        state.quest.rewardScore = Math.floor(state.quest.rewardScore * 1.1 + 20);
        showToast("Quest complete! Reward granted");
      }
    }

    function rotateWorldEvent() {
      const cycle = ["Calm", "Frenzy Hunt", "Storm Wind"];
      const idx = cycle.indexOf(state.worldEvent.type);
      state.worldEvent.type = cycle[(idx + 1) % cycle.length];
      state.worldEvent.timer = 28;
      showToast(`World Event: ${state.worldEvent.type}`);
    }

    function updateWorldSystems(dt) {
      state.worldEvent.timer -= dt;
      if (state.worldEvent.timer <= 0) rotateWorldEvent();
      state.match.spawnShield = Math.max(0, state.match.spawnShield - dt);
      state.fx.hitFlash = Math.max(0, state.fx.hitFlash - dt * 1.9);
      state.fx.shakeTime = Math.max(0, state.fx.shakeTime - dt);
      if (state.fx.shakeTime <= 0) state.fx.shakePower = 0;
      for (const item of state.match.killfeed) item.ttl -= dt;
      state.match.killfeed = state.match.killfeed.filter((k) => k.ttl > 0);
      state.ecosystem.rareFoodTimer -= dt;
      if (state.ecosystem.rareFoodTimer <= 0) {
        spawnRareFood();
        state.ecosystem.rareFoodTimer = randomInt(14, 24);
      }
      if (state.score >= state.match.bountyScore) {
        pushKillfeed(`Bounty reached: ${state.match.bountyScore}`, "#ffcf7d");
        const step = state.match.bountyStep || 600;
        state.match.bountyScore = (Math.floor(state.score / step) + 1) * step;
      }
      const daySpeed = state.settings.reduceMotion ? 0.0035 : 0.006;
      state.visual.dayPhase = (state.visual.dayPhase + dt * daySpeed) % 1;
      const biomeName = biomeAtX(state.player.x).name;
      if (biomeName !== state.currentBiome) {
        state.currentBiome = biomeName;
        setBiomeMission(biomeName);
        showToast(`Entered ${biomeName}`);
      }

      if (state.objective) {
        state.objective.timeLeft -= dt;
        if (state.objective.timeLeft <= 0) {
          state.objectiveStats.difficulty = clamp((state.objectiveStats.difficulty || 0) - 1, -2, 2);
          pushKillfeed("Objective expired", "#ffb8b8");
          setNextObjective("timeout");
        }
      }

      if (state.death.revengeActive && state.death.lastX != null) {
        const p = state.player;
        const dist = Math.hypot(p.x - state.death.lastX, p.y - state.death.lastY);
        if (dist < 90) {
          const reward = Math.floor(state.death.revengeXp * xpMultiplier());
          p.xp += reward;
          state.score += 80;
          state.death.revengeActive = false;
          addCombatText(p.x, p.y - p.size * 0.9, `REVENGE +${reward} XP`, "#c6f8ff", 15);
          pushKillfeed("Revenge bonus claimed", "#c6f8ff");
          showToast("Revenge claimed");
          applyImpactFx(0.74, 0.15, 0.01);
        }
      }

      updateRunProgressionHooks();
      runSpawnDirector(dt);
    }

    function updateAutoPerformance(dt) {
      state.performance.cooldown = Math.max(0, state.performance.cooldown - dt);
      if (!state.settings.autoPerformance) {
        state.performance.lowFpsTimer = Math.max(0, state.performance.lowFpsTimer - dt * 2);
        return;
      }

      const fps = state.hudFps || 60;
      if (fps < 45) {
        state.performance.lowFpsTimer += dt;
      } else {
        state.performance.lowFpsTimer = Math.max(0, state.performance.lowFpsTimer - dt * 1.5);
      }

      if (state.performance.lowFpsTimer < 6 || state.performance.cooldown > 0) return;

      let changed = false;
      let nextQuality = state.quality;
      if (state.quality === "ultra") {
        nextQuality = "high";
        changed = true;
      } else if (state.quality === "high") {
        nextQuality = "medium";
        changed = true;
      }
      if (!state.settings.reduceMotion) {
        state.settings.reduceMotion = true;
        changed = true;
      }
      if (state.quality === "medium" && state.settings.advancedHud) {
        state.settings.advancedHud = false;
        changed = true;
      }
      if (!changed) {
        state.performance.cooldown = 18;
        state.performance.lowFpsTimer = 0;
        return;
      }

      state.quality = nextQuality;
      state.performance.cooldown = 18;
      state.performance.lowFpsTimer = 0;
      syncSettingsUi();
      applySettingsFromUi(true, state.signedUp);
      showToast(`Auto Performance: switched to ${state.quality.toUpperCase()}`);
    }

    function hazardAtX(x) {
      return hazardZones.find((z) => x >= z.start && x <= z.end) || null;
    }

    function spawnRareFood() {
      const x = clamp(state.player.x + randomInt(-1300, 1300), 100, WORLD.width - 100);
      const source = Math.random() < 0.5 ? "tree" : "floor";
      const y = source === "tree" ? groundY(x) - randomInt(95, 160) : groundY(x) - randomInt(3, 10);
      const item = Math.random() < 0.5 ? "berry" : "pumpkin";
      state.resources.push({
        x,
        y,
        size: randomInt(13, 16),
        source,
        nutrition: "plant",
        item,
        xp: 120,
        score: 75,
        rare: true
      });
      pushKillfeed("Rare food spawned", "#ffe082");
    }

    function updateSurvival(dt) {
      const p = state.player;
      const s = state.survival;
      const perks = tierPerkProfile(p.tier);
      const moving = Math.abs(p.vx) > 70 || Math.abs(p.vy) > 80;
      const sprinting = isActionPressed("sprint");
      const flying = isAirTier(p.tier) && !p.grounded;
      const baseEnergyDrain = 0.7;
      const baseHydrationDrain = 0.55;
      const activityBoost = (moving ? 0.55 : 0) + (sprinting ? 0.65 : 0) + (flying ? 0.45 : 0);
      const biome = state.currentBiome;
      const biomeHydrationBoost = biome === "Amber Dunes" ? 0.5 : (biome === "Ash Ridge" ? 0.2 : 0);
      const biomeEnergyBoost = biome === "Frost Reach" ? 0.24 : 0;
      s.energy = clamp(s.energy - (baseEnergyDrain + activityBoost + biomeEnergyBoost) * dt * perks.sustainMult, 0, 100);
      s.hydration = clamp(s.hydration - (baseHydrationDrain + activityBoost * 0.5 + biomeHydrationBoost) * dt * perks.sustainMult, 0, 100);
      const highSky = p.y < groundY(p.x) - 280;
      if (highSky) {
        s.oxygen = clamp(s.oxygen - (2.8 + activityBoost * 0.8) * dt * perks.sustainMult, 0, 100);
      } else {
        s.oxygen = clamp(s.oxygen + 14 * dt, 0, 100);
      }

      const hz = hazardAtX(p.x);
      if (hz && p.y > groundY(p.x) - 40) {
        s.tickDamageCd -= dt;
        if (s.tickDamageCd <= 0) {
          const tick = Math.max(4, Math.floor(hz.dps * 0.28));
          p.hp -= tick;
          s.tickDamageCd = 0.45;
          addCombatText(p.x, p.y - p.size * 0.7, `-${tick} ${hz.type.toUpperCase()}`, "#ff8e8e", 13);
          applyImpactFx(0.35, 0.08, 0.006);
          if (p.hp <= 0) {
            resetIfDefeated(`${hz.type} zone`);
            return;
          }
        }
      }

      if (s.energy <= 0 || s.hydration <= 0 || s.oxygen <= 0) {
        s.tickDamageCd -= dt;
        if (s.tickDamageCd <= 0) {
          p.hp -= 4;
          s.tickDamageCd = 0.8;
          addCombatText(p.x, p.y - p.size * 0.7, "-4", "#ff8e8e", 14);
          applyImpactFx(0.25, 0.06, 0.004);
          if (p.hp <= 0) {
            resetIfDefeated("survival pressure");
            return;
          }
        }
      } else {
        s.tickDamageCd = Math.max(0, s.tickDamageCd - dt * 0.2);
      }
    }

    function survivalSpeedMultiplier() {
      const s = state.survival;
      const low = Math.min(s.energy, s.hydration);
      if (low > 60) return 1;
      if (low > 35) return 0.92;
      if (low > 15) return 0.82;
      return 0.72;
    }

    function worldToScreen(wx, wy) {
      return {
        x: wx - state.camera.x,
        y: wy - state.camera.y
      };
    }

    function inView(wx, wy, pad = 50) {
      const s = worldToScreen(wx, wy);
      return s.x > -pad && s.x < canvas.width + pad && s.y > -pad && s.y < canvas.height + pad;
    }

    function jumpHeld() {
      return isActionPressed("jump") || isActionPressed("moveUp");
    }

    function downHeld() {
      return isActionPressed("moveDown");
    }

    function canEatFromTree(tier) {
      return tier <= 3 || (tier >= 6 && tier <= 24) || tier >= 28;
    }

    function canEatFromFloor(tier) {
      return tier <= 12 || tier >= 18;
    }

    function canConsumeResource(tier, resource) {
      if (resource.source === "tree" && !canEatFromTree(tier)) return false;
      if (resource.source === "floor" && !canEatFromFloor(tier)) return false;
      if (resource.nutrition === "meat") return tier >= 4 || tier >= 28;
      return true;
    }

    function spriteKeyForTier(tier) {
      if (tier === 1) return "ant";
      if (tier === 2) return "mouse";
      if (tier === 3) return "rabbit";
      if (tier <= 5) return "fox";
      if (tier <= 10) return "owl";
      if (tier <= 17) return "eagle";
      if (tier <= 27) return "dragon";
      if (tier === 28) return "moon3";
      if (tier === 29) return "moon2";
      if (tier === 30) return "moon1";
      return "moon";
    }

    function initSprites() {
      for (const [key, src] of Object.entries(spriteManifest)) {
        const img = new Image();
        img.src = `${src}?${SPRITE_VERSION}`;
        spriteCache[key] = img;
      }
      for (const [key, src] of Object.entries(foodSpriteManifest)) {
        const img = new Image();
        img.src = `${src}?${SPRITE_VERSION}`;
        foodSpriteCache[key] = img;
      }
    }

    function initGraphicsAssets() {
      const tex = document.createElement("canvas");
      tex.width = 180;
      tex.height = 180;
      const tctx = tex.getContext("2d");
      const g = tctx.createLinearGradient(0, 0, 0, tex.height);
      g.addColorStop(0, "rgba(100,72,42,0.3)");
      g.addColorStop(1, "rgba(58,40,25,0.32)");
      tctx.fillStyle = g;
      tctx.fillRect(0, 0, tex.width, tex.height);
      tctx.fillStyle = "rgba(255,255,255,0.05)";
      for (let i = 0; i < 64; i++) {
        const x = (i * 41) % tex.width;
        const y = (i * 67) % tex.height;
        tctx.beginPath();
        tctx.arc(x, y, 0.8 + (i % 2), 0, Math.PI * 2);
        tctx.fill();
      }
      state.gfx.soilPattern = ctx.createPattern(tex, "repeat");
    }

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(640, Math.round(rect.width));
      const height = Math.max(360, Math.round(rect.height));
      if (canvas.width === width && canvas.height === height) return false;
      canvas.width = width;
      canvas.height = height;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      return true;
    }

    function syncCamera(dt) {
      const p = state.player;
      const viewW = canvas.width;
      const viewH = canvas.height;
      const centerX = state.camera.x + viewW * 0.5;
      const centerY = state.camera.y + viewH * 0.54;
      const deadX = viewW * CAMERA.deadZoneXRatio;
      const deadY = viewH * CAMERA.deadZoneYRatio;

      let followCenterX = centerX;
      let followCenterY = centerY;
      if (p.x < centerX - deadX) followCenterX = p.x + deadX;
      else if (p.x > centerX + deadX) followCenterX = p.x - deadX;

      if (p.y < centerY - deadY) followCenterY = p.y + deadY;
      else if (p.y > centerY + deadY) followCenterY = p.y - deadY;

      const lookAheadX = clamp(
        p.vx * CAMERA.lookAheadXRatio,
        -CAMERA.lookAheadXMax,
        CAMERA.lookAheadXMax
      );
      const lookAheadY = clamp(
        p.vy * CAMERA.lookAheadYRatio,
        -CAMERA.lookAheadYMax,
        CAMERA.lookAheadYMax
      );
      const targetX = clamp(
        followCenterX + lookAheadX - viewW * 0.5,
        0,
        WORLD.width - viewW
      );
      const targetY = clamp(
        followCenterY + lookAheadY - viewH * 0.54,
        0,
        WORLD.height - viewH
      );
      const followX = state.settings.reduceMotion ? CAMERA.followXReduce : CAMERA.followX;
      const followY = state.settings.reduceMotion ? CAMERA.followYReduce : CAMERA.followY;
      const sx = 1 - Math.exp(-followX * dt);
      const sy = 1 - Math.exp(-followY * dt);
      state.camera.x += (targetX - state.camera.x) * sx;
      state.camera.y += (targetY - state.camera.y) * sy;
    }

    function spawnResource(kind = "auto") {
      let x = clamp(state.player.x + randomInt(-1400, 1400), 80, WORLD.width - 80);
      if (Math.random() < 0.22) {
        const near = nearestLandmark(state.player.x);
        if (near && near.dist < 2600) {
          x = clamp(near.landmark.x + randomInt(-360, 360), 80, WORLD.width - 80);
        }
      }
      const biome = biomeAtX(x);
      const zone = zoneTierBandAtX(x);
      let source;
      let nutrition;
      if (kind === "tree") {
        source = "tree";
        nutrition = Math.random() < 0.7 ? "plant" : "meat";
      } else if (kind === "floor") {
        source = "floor";
        nutrition = Math.random() < 0.65 ? "plant" : "meat";
      } else {
        const treeBias = biome.name === "Greenwood" ? 0.62 : (biome.name === "Frost Reach" ? 0.52 : 0.32);
        source = Math.random() < treeBias ? "tree" : "floor";
        const meatBias = clamp((zone.max - 4) / 34, 0.18, 0.52);
        nutrition = Math.random() < (1 - meatBias) ? "plant" : "meat";
      }

      const y = source === "tree"
        ? groundY(x) - randomInt(95, 170)
        : groundY(x) - randomInt(2, 8);
      const size = source === "tree" ? randomInt(8, 12) : randomInt(9, 13);
      const zoneScale = 1 + zone.max * 0.03;
      const xp = Math.floor((nutrition === "meat" ? 22 : 16) * zoneScale);
      const score = Math.floor((nutrition === "meat" ? 11 : 8) * zoneScale);
      let item;
      if (source === "tree") {
        item = nutrition === "plant"
          ? (Math.random() < 0.5 ? "apple" : "banana")
          : "berry";
      } else {
        item = nutrition === "plant"
          ? (Math.random() < 0.5 ? "carrot" : "pumpkin")
          : "mushroom";
      }
      state.resources.push({ x, y, size, source, nutrition, item, xp, score });
    }

    function maintainResources() {
      let treeCount = 0;
      let floorCount = 0;
      for (const r of state.resources) {
        if (r.source === "tree") treeCount++;
        else floorCount++;
      }
      while (state.resources.length < FOOD_TARGET) {
        if (treeCount <= floorCount) {
          spawnResource("tree");
          treeCount++;
        } else {
          spawnResource("floor");
          floorCount++;
        }
      }
    }

    function updateResources() {
      const p = state.player;
      const sv = state.survival;
      const perks = tierPerkProfile(p.tier);
      for (let i = state.resources.length - 1; i >= 0; i--) {
        const r = state.resources[i];
        const dist = Math.hypot(r.x - p.x, r.y - p.y);
        if (dist < p.size * 0.75 + r.size * 0.95 && canConsumeResource(p.tier, r)) {
          state.resources.splice(i, 1);
          const gainXp = r.xp * xpMultiplier() * perks.forageBoost;
          p.xp += gainXp;
          state.score += r.score;
          if (r.source === "tree") {
            sv.hydration = clamp(sv.hydration + (r.nutrition === "plant" ? 12 : 8) * perks.sustainMult, 0, 100);
            sv.energy = clamp(sv.energy + (r.nutrition === "plant" ? 6 : 4) * perks.sustainMult, 0, 100);
          } else {
            sv.energy = clamp(sv.energy + (r.nutrition === "plant" ? 10 : 14) * perks.sustainMult, 0, 100);
            sv.hydration = clamp(sv.hydration + (r.nutrition === "plant" ? 5 : 2) * perks.sustainMult, 0, 100);
          }
          if (r.rare) {
            sv.oxygen = clamp(sv.oxygen + 18, 0, 100);
            addCombatText(r.x, r.y - 18, `RARE +${Math.floor(gainXp)} XP`, "#ffe793", 15);
            pushKillfeed("Rare food consumed", "#ffe793");
            applyImpactFx(0.56, 0.14, 0.008);
          }
          if (state.biomeMission.type === "tree_food" && r.source === "tree") {
            addBiomeMissionProgress(1);
          }
          if (r.source === "tree") state.foodStats.tree++;
          else state.foodStats.floor++;
          if (r.source === "tree") addObjectiveProgress("eat_tree", 1);
          else addObjectiveProgress("eat_floor", 1);
          state.quest.progress += 1;
          if (state.quest.progress >= state.quest.target) {
            state.quest.progress -= state.quest.target;
            p.xp += state.quest.rewardXp;
            state.score += state.quest.rewardScore;
            state.quest.target = Math.min(36, state.quest.target + 3);
            state.quest.rewardXp = Math.floor(state.quest.rewardXp * 1.12 + 30);
            state.quest.rewardScore = Math.floor(state.quest.rewardScore * 1.1 + 20);
            showToast("Quest complete! Reward granted");
          }
        }
      }
      maintainResources();
    }

    function spawnBot(kind = "auto") {
      const x = clamp(
        state.player.x + randomInt(-1500, 1500),
        80,
        WORLD.width - 80
      );
      const zone = zoneTierBandAtX(x);
      let tier;
      if (kind === "air") {
        const minTier = Math.max(6, zone.min + 2);
        const maxTier = Math.min(30, zone.max + 5);
        tier = randomInt(minTier, Math.max(minTier, maxTier));
      } else if (kind === "ground") {
        const minTier = Math.max(1, zone.min - 2);
        const maxTier = Math.min(12, zone.max);
        tier = randomInt(minTier, Math.max(minTier, maxTier));
      } else if (kind === "prey") {
        const minTier = Math.max(1, zone.min - 2);
        const maxTier = Math.max(minTier, Math.max(1, state.player.tier));
        tier = randomInt(minTier, maxTier);
      } else {
        const tierMin = Math.max(1, zone.min - 1, state.player.tier - 3);
        const tierMaxRaw = Math.min(30, zone.max + 2, state.player.tier + 4);
        const tierMax = Math.max(tierMin, tierMaxRaw);
        tier = randomInt(tierMin, tierMax);
      }
      // Stream creatures around the player so a huge world still feels populated.
      const fly = isAirTier(tier);
      const y = fly
        ? clamp(state.player.y + randomInt(-260, -70), 180, WORLD.height - 520)
        : Math.floor(groundY(x) - randomInt(0, 6));
      const elite = Math.random() < (state.worldEvent.type === "Frenzy Hunt" ? 0.13 : 0.06);

      state.bots.push({
        x,
        y,
        vx: (Math.random() - 0.5) * (fly ? 2.1 : 1.4),
        vy: (Math.random() - 0.5) * (fly ? 1.6 : 0.3),
        tier,
        size: (22 + tier * 0.9) * (elite ? 1.25 : 1),
        elite,
        kind: fly ? "air" : "ground",
        behaviorSeed: Math.random() * 10
      });
    }

    function maintainPopulation() {
      let air = 0;
      let ground = 0;
      for (const b of state.bots) {
        if (b.kind === "air") air++;
        else ground++;
      }

      const zone = zoneTierBandAtX(state.player.x);
      const zoneBoost = Math.floor(zone.max / 8);
      const dynamicTargetRaw = BOT_TARGET + Math.floor(zone.max / 10) + (state.worldEvent.type === "Frenzy Hunt" ? 3 : 0);
      const dynamicTarget = clamp(dynamicTargetRaw, BOT_TARGET, BOT_TARGET + 8);
      while (air < MIN_FLYING_BOTS && state.bots.length < dynamicTarget) {
        spawnBot("air");
        air++;
      }
      while (ground < MIN_GROUND_BOTS && state.bots.length < dynamicTarget) {
        spawnBot("ground");
        ground++;
      }
      while (state.bots.length < dynamicTarget) {
        spawnBot(air <= ground ? "air" : "ground");
        if (air <= ground) air++;
        else ground++;
      }

      let edible = 0;
      for (const b of state.bots) {
        if (canConsume(state.player.tier, b.tier)) edible++;
      }

      const edibleTarget = MIN_EDIBLE_BOTS + Math.max(0, 2 - zoneBoost) + (state.worldEvent.type === "Frenzy Hunt" ? 2 : 1);
      while (edible < edibleTarget) {
        if (state.bots.length < dynamicTarget) {
          spawnBot("prey");
          edible++;
          continue;
        }
        const replaceIdx = state.bots.findIndex((b) => !canConsume(state.player.tier, b.tier));
        if (replaceIdx === -1) break;
        state.bots.splice(replaceIdx, 1);
        spawnBot("prey");
        edible++;
      }
    }

    function maintainBosses(dt) {
      state.bossSystem.cooldown = Math.max(0, state.bossSystem.cooldown - dt);
      for (let i = state.bosses.length - 1; i >= 0; i--) {
        const b = state.bosses[i];
        if (Math.abs(b.x - state.player.x) > 7200) {
          b.despawnTimer -= dt;
          if (b.despawnTimer <= 0) state.bosses.splice(i, 1);
        } else {
          b.despawnTimer = 70;
        }
      }
      if (!canSpawnBoss()) return;
      const inBiomeCount = state.bosses.filter((b) => b.biome === state.currentBiome).length;
      if (inBiomeCount === 0) spawnBoss(state.currentBiome);
    }

    function distancePointToSegment(px, py, ax, ay, bx, by) {
      const abx = bx - ax;
      const aby = by - ay;
      const apx = px - ax;
      const apy = py - ay;
      const denom = abx * abx + aby * aby || 1;
      const t = clamp((apx * abx + apy * aby) / denom, 0, 1);
      const qx = ax + abx * t;
      const qy = ay + aby * t;
      return Math.hypot(px - qx, py - qy);
    }

    function applyBossPlayerHit(boss, amount, impulse = 1, text = "") {
      const p = state.player;
      if (p.invulnTimer > 0 || state.match.spawnShield > 0) return false;
      const dmg = Math.max(1, Math.floor(amount * damageTakenMultiplier()));
      p.hp -= dmg;
      p.invulnTimer = 0.7;
      const dx = p.x - boss.x;
      const dy = p.y - boss.y;
      const dist = Math.max(1, Math.hypot(dx, dy));
      p.vx += (dx / dist) * (120 * impulse);
      p.vy += (dy / dist) * (75 * impulse) - 70;
      addCombatText(p.x, p.y - p.size * 0.7, `-${dmg}`, "#ff8e8e", 16);
      applyImpactFx(0.74, 0.2, 0.012);
      if (text) {
        pushKillfeed(`${boss.name}: ${text}`, "#ffc89b");
      }
      if (p.hp <= 0) {
        resetIfDefeated(`boss ${boss.name}`);
      }
      return true;
    }

    function queueBossTelegraph(b, p) {
      const phase = b.phase || 1;
      const timerBase = Math.max(0.38, 0.82 - phase * 0.09);
      if (b.kind === "ground") {
        if (Math.random() < 0.58) {
          b.telegraph = {
            kind: "aoe",
            name: phase >= 3 ? "Rupture" : "Ground Slam",
            timer: timerBase,
            duration: timerBase,
            x: b.x,
            y: b.y,
            radius: 128 + phase * 32,
            damage: 14 + phase * 5,
            push: 170 + phase * 36
          };
        } else {
          const dx = p.x - b.x;
          const dy = (p.y - b.y) * 0.45;
          const norm = Math.max(1, Math.hypot(dx, dy));
          b.telegraph = {
            kind: "dash",
            name: phase >= 3 ? "Brutal Rush" : "Rush",
            timer: Math.max(0.34, timerBase - 0.08),
            duration: Math.max(0.34, timerBase - 0.08),
            x: b.x,
            y: b.y,
            dirX: dx / norm,
            dirY: dy / norm,
            distance: 250 + phase * 82,
            width: 58 + phase * 8,
            speed: 540 + phase * 90,
            damage: 12 + phase * 5,
            push: 220 + phase * 48
          };
        }
      } else {
        if (Math.random() < 0.56) {
          const tx = p.x + p.vx * 0.24;
          const ty = p.y + p.vy * 0.18;
          const dx = tx - b.x;
          const dy = ty - b.y;
          const norm = Math.max(1, Math.hypot(dx, dy));
          b.telegraph = {
            kind: "dash",
            name: phase >= 3 ? "Sky Dive" : "Dive",
            timer: Math.max(0.32, timerBase - 0.12),
            duration: Math.max(0.32, timerBase - 0.12),
            x: b.x,
            y: b.y,
            dirX: dx / norm,
            dirY: dy / norm,
            distance: 300 + phase * 92,
            width: 52 + phase * 7,
            speed: 620 + phase * 96,
            damage: 12 + phase * 4,
            push: 210 + phase * 36
          };
        } else {
          b.telegraph = {
            kind: "aoe",
            name: phase >= 3 ? "Cyclone Burst" : "Wind Burst",
            timer: timerBase,
            duration: timerBase,
            x: p.x + p.vx * 0.2,
            y: p.y + p.vy * 0.15,
            radius: 138 + phase * 30,
            damage: 10 + phase * 4,
            push: 210 + phase * 45
          };
        }
      }
    }

    function resolveBossTelegraph(b) {
      const p = state.player;
      const t = b.telegraph;
      if (!t) return;
      if (t.kind === "dash") {
        b.vx += t.dirX * t.speed;
        b.vy += t.dirY * t.speed * (b.kind === "air" ? 0.72 : 0.4);
        const ex = t.x + t.dirX * t.distance;
        const ey = t.y + t.dirY * t.distance;
        const lineDist = distancePointToSegment(p.x, p.y, t.x, t.y, ex, ey);
        if (lineDist < t.width + p.size * 0.4) {
          const hit = applyBossPlayerHit(b, t.damage, 1.15, t.name);
          if (hit) {
            p.vx += t.dirX * t.push;
            p.vy += t.dirY * t.push * 0.36;
          }
        }
        addCombatText(ex, ey - 18, t.name, "#ffd7a1", 13);
      } else {
        const dist = Math.hypot(p.x - t.x, p.y - t.y);
        if (dist < t.radius + p.size * 0.5) {
          const hit = applyBossPlayerHit(b, t.damage, 1.1, t.name);
          if (hit) {
            const nx = (p.x - t.x) / Math.max(1, dist);
            const ny = (p.y - t.y) / Math.max(1, dist);
            p.vx += nx * t.push;
            p.vy += ny * t.push * 0.34 - 30;
          }
        }
        addCombatText(t.x, t.y - Math.min(110, t.radius * 0.4), t.name, "#ffd7a1", 13);
      }
      b.telegraph = null;
      const phaseRate = 1 + ((b.phase || 1) - 1) * 0.22;
      b.abilityCd = randomInt(34, 56) / 10 / phaseRate;
    }

    function updateBosses(dt) {
      const p = state.player;
      if (state.match.spawnShield > 0) {
        maintainBosses(dt);
        return;
      }
      for (let i = state.bosses.length - 1; i >= 0; i--) {
        const b = state.bosses[i];
        const hpRatio = clamp(b.hp / Math.max(1, b.maxHp), 0, 1);
        const nextPhase = hpRatio <= 0.33 ? 3 : (hpRatio <= 0.66 ? 2 : 1);
        if ((b.phase || 1) !== nextPhase) {
          b.phase = nextPhase;
          if (nextPhase >= 2) {
            showToast(`${b.name} phase ${nextPhase}`);
            pushKillfeed(`${b.name} entered phase ${nextPhase}`, "#ffd7a8");
          }
        }
        b.enraged = nextPhase >= 3;

        const dx = p.x - b.x;
        const dy = p.y - b.y;
        const dist = Math.max(1, Math.hypot(dx, dy));
        const phaseSpeed = 1 + ((b.phase || 1) - 1) * 0.18 + (b.enraged ? 0.08 : 0);

        if (b.hitCd > 0) b.hitCd -= dt;
        b.abilityCd = Math.max(0, (b.abilityCd || 0) - dt);
        if (b.telegraph) {
          b.telegraph.timer -= dt;
          if (b.telegraph.timer <= 0) {
            resolveBossTelegraph(b);
          } else {
            b.vx *= 0.9;
            b.vy *= 0.92;
          }
        } else if (dist < (b.phase >= 2 ? 1360 : 1180) && b.abilityCd <= 0) {
          queueBossTelegraph(b, p);
        }

        const chaseVx = clamp(dx * 0.7 * phaseSpeed, -260 * phaseSpeed, 260 * phaseSpeed);
        b.vx += (chaseVx - b.vx) * (1 - Math.exp(-2.6 * dt));

        if (b.kind === "air") {
          const targetY = clamp(p.y - 60 + Math.sin((Date.now() + i * 500) * 0.002) * 50, 95, groundY(b.x) - 80);
          const chaseVy = clamp((targetY - b.y) * 1.7 * phaseSpeed, -230 * phaseSpeed, 230 * phaseSpeed);
          b.vy += (chaseVy - b.vy) * (1 - Math.exp(-2.2 * dt));
        } else {
          const g = groundY(b.x);
          if (b.y >= g - 1) {
            b.y = g;
            if (!b.telegraph && Math.abs(dx) < 340 && Math.random() < dt * (2.0 + (b.phase || 1) * 0.8)) {
              b.vy = -680 - (b.phase || 1) * 40;
            }
          } else {
            b.vy += MOVEMENT.gravity * 0.9 * dt;
            b.vy = Math.min(b.vy, 980);
          }
        }

        if (state.worldEvent.type === "Storm Wind") {
          b.vx += Math.sin((Date.now() + b.x * 0.03) * 0.0018) * 9 * dt;
        }

        b.x = clamp(b.x + b.vx * dt, 24, WORLD.width - 24);
        b.y += b.vy * dt;

        if (b.kind === "air") {
          const floor = groundY(b.x) - 32;
          if (b.y > floor) {
            b.y = floor;
            b.vy = Math.min(0, b.vy * -0.25);
          }
          b.y = clamp(b.y, 90, WORLD.height - 90);
        } else {
          const floor = groundY(b.x);
          if (b.y > floor) {
            b.y = floor;
            b.vy = 0;
          }
        }

        const hitRange = p.size * 0.62 + b.size * 0.56;
        const colliding = dist < hitRange;
        if (colliding) {
          const moonStrikeActive = isMoonTier(p.tier) && p.attackCd > 10;
          const canDamageBoss = canConsume(p.tier, b.tier) && (moonStrikeActive || p.tier >= b.tier + 2);
          if (canDamageBoss && b.hitCd <= 0) {
            const dmgBase = moonStrikeActive ? 180 : 70;
            const dmg = Math.floor((dmgBase + p.tier * 3.5) * tierPerkProfile(p.tier).moonPower * moonDamageMultiplier());
            b.hp -= dmg;
            b.hitCd = 0.22;
            b.vx += Math.sign(dx || 1) * -120;
            if (b.telegraph) {
              b.telegraph.timer += 0.18;
              b.abilityCd = Math.max(b.abilityCd, 0.9);
            }
            addCombatText(b.x, b.y - b.size * 0.75, `-${dmg}`, "#ffce8a", 15);
            addObjectiveProgress("boss_hit", 1);
            applyImpactFx(0.62, 0.14, 0.009);
            if (b.hp <= 0) {
              rewardBossDefeat(b);
              state.bosses.splice(i, 1);
              continue;
            }
            if (moonStrikeActive) showToast(`${b.name} hit (${Math.max(0, b.hp)} HP)`);
            continue;
          }

          if (b.hitCd <= 0) {
            const bossHit = Math.max(20, Math.floor(b.tier * (1.25 + (b.phase || 1) * 0.08)));
            const hit = applyBossPlayerHit(b, bossHit, 1);
            if (hit) {
              b.hitCd = 0.7;
              showToast(`${b.name} struck you`);
              if (state.match.respawnTimer > 0) break;
            }
          }
        }
      }
      maintainBosses(dt);
    }

    function updateHud() {
      const p = state.player;
      let activeBoss = null;
      let nearestBossDist = Number.POSITIVE_INFINITY;
      for (const b of state.bosses) {
        const d = Math.hypot(b.x - p.x, b.y - p.y);
        if (d < nearestBossDist) {
          nearestBossDist = d;
          activeBoss = b;
        }
      }
      ui.formName.textContent = tiers[p.tier - 1];
      ui.tierLabel.textContent = `${p.tier} / 30`;
      ui.speedLabel.textContent = state.subscribed ? "Subscribed (+60%)" : "Free";
      ui.scoreLabel.textContent = state.score;
      ui.abQ.textContent = fmtCd(state.abilities.q.cd);
      ui.abE.textContent = fmtCd(state.abilities.e.cd);
      ui.abF.textContent = fmtCd(state.abilities.f.cd);
      ui.netState.textContent = state.net.connected ? "Online" : "Offline";
      ui.onlineCount.textContent = String(state.net.onlineCount || 1);
      const bossText = activeBoss
        ? ` | Boss: ${activeBoss.name} P${activeBoss.phase || 1} ${Math.max(0, Math.ceil((activeBoss.hp / activeBoss.maxHp) * 100))}% ${activeBoss.telegraph ? `[CAST ${activeBoss.telegraph.name}]` : (nearestBossDist < 1200 ? "[ENGAGED]" : "[HUNTING]")}`
        : ` | Boss: none (${Math.ceil(state.bossSystem.cooldown)}s)`;
      ui.eventText.textContent = `Event: ${state.worldEvent.type} (${Math.ceil(state.worldEvent.timer)}s) | Biome: ${state.currentBiome}${bossText}`;
      const objectiveText = state.objective
        ? `${state.objective.label} ${state.objective.progress}/${state.objective.target} (${Math.ceil(state.objective.timeLeft)}s)`
        : "none";
      ui.questText.textContent = `Quest: Eat ${state.quest.progress} / ${state.quest.target} | Biome Task: ${biomeMissionLabel()} ${state.biomeMission.progress}/${state.biomeMission.target} | Goal: ${objectiveText}`;
      if (state.net.leaderboard.length > 0) {
        ui.leaderboardText.textContent = "Leaderboard: " + state.net.leaderboard
          .slice(0, 3)
          .map((x) => `${x.name || "Player"}(${x.score || 0})`)
          .join(" | ");
      } else {
        ui.leaderboardText.textContent = "Leaderboard: no data yet";
      }
      ui.xpBar.style.width = Math.min(100, (p.xp / p.xpToNext) * 100) + "%";
      const xpLabel = p.tier >= 30 ? "MAX" : `${Math.floor(p.xp)} / ${p.xpToNext}`;
      if (state.settings.advancedHud) {
        const tunnelDistance = Math.max(0, Math.floor((TUNNEL.entranceX - p.x) / 100));
        let air = 0;
        for (const b of state.bots) {
          if (b.kind === "air") air++;
        }
        const ground = state.bots.length - air;
        let edible = 0;
        for (const b of state.bots) {
          if (canConsume(p.tier, b.tier)) edible++;
        }
        ui.xpText.textContent = `XP: ${xpLabel} | HP:${Math.max(0, Math.floor(p.hp))} | EN:${Math.floor(state.survival.energy)} HY:${Math.floor(state.survival.hydration)} OX:${Math.floor(state.survival.oxygen)} | Biome:${state.currentBiome} | X:${Math.floor(p.x)} | Tunnel:${tunnelDistance} | Ground:${ground} Air:${air} Edible:${edible}`;
      } else {
        ui.xpText.textContent = `XP: ${xpLabel} | HP:${Math.max(0, Math.floor(p.hp))} | EN:${Math.floor(state.survival.energy)} HY:${Math.floor(state.survival.hydration)} OX:${Math.floor(state.survival.oxygen)}`;
      }
      const treeOk = canEatFromTree(p.tier) ? "yes" : "no";
      const floorOk = canEatFromFloor(p.tier) ? "yes" : "no";
      const nearItems = state.resources
        .filter((r) => Math.abs(r.x - p.x) < 700)
        .slice(0, 3)
        .map((r) => r.item)
        .join(", ");
      ui.foodText.textContent = `Food eaten: Tree ${state.foodStats.tree} | Floor ${state.foodStats.floor} | Relic:${state.loot.relics} Shard:${state.loot.shards} Core:${state.loot.cores} | Upgrades A/G/M:${upgradeLevel("aero")}/${upgradeLevel("guard")}/${upgradeLevel("moon")} | Can eat tree:${treeOk} floor:${floorOk}${nearItems ? ` | Nearby: ${nearItems}` : ""}`;
    }

    function handleLevelUp() {
      const p = state.player;
      const wasAir = isAirTier(p.tier);
      while (p.xp >= p.xpToNext && p.tier < 30) {
        p.xp -= p.xpToNext;
        p.tier += 1;
        p.xpToNext = Math.floor(p.xpToNext * 1.18 + 20);
        p.size = entitySizeForTier(p.tier);
        playSfx("level");
        showToast(`Tier Up: ${tiers[p.tier - 1]}`);
      }
      if (p.tier >= 30) {
        p.xp = clamp(p.xp, 0, p.xpToNext);
      }
      if (!wasAir && isAirTier(p.tier)) {
        playSfx("tap");
        showToast("Flight unlocked at tier 6");
      }
    }

    function resetIfDefeated(reason = "stronger beast") {
      if (state.match.respawnTimer > 0) return;
      state.death.lastX = state.player.x;
      state.death.lastY = state.player.y;
      state.death.reason = reason;
      state.death.tier = state.player.tier;
      state.death.streakLost = state.match.streak;
      state.death.revengeActive = true;
      state.death.revengeXp = Math.floor(90 + state.player.tier * 4);
      state.match.deathReason = reason;
      state.match.respawnTimer = 2.8;
      state.match.spawnShield = 0;
      state.match.streak = 0;
      state.objectiveStats.difficulty = clamp((state.objectiveStats.difficulty || 0) - 1, -2, 2);
      applyImpactFx(0.95, 0.28, 0.02);
      pushKillfeed(`You were defeated (${reason})`, "#ffb6b6");
      showToast("Defeated - respawning...");
    }

    function performRespawn() {
      const p = state.player;
      const sv = state.survival;
      p.tier = Math.max(1, p.tier - 1);
      p.xp = 0;
      p.xpToNext = Math.max(50, Math.floor(p.xpToNext * 0.9));
      p.size = entitySizeForTier(p.tier);
      p.x = 180;
      p.y = groundY(180);
      p.vx = 0;
      p.vy = 0;
      p.moonCombo = 0;
      p.grounded = true;
      p.coyoteTimer = 0;
      p.jumpBufferTimer = 0;
      p.invulnTimer = 1.1;
      p.flapCd = 0;
      p.tunnelCd = 0;
      p.hp = 100;
      sv.energy = 72;
      sv.hydration = 72;
      sv.oxygen = 72;
      sv.tickDamageCd = 0;
      state.match.spawnShield = 4;
      state.match.respawnTimer = 0;
      setNextObjective("respawn");
      showToast("Respawned (shield 4s)");
    }

    function testerRespawn() {
      const p = state.player;
      const sv = state.survival;
      p.x = 180;
      p.y = groundY(180);
      p.vx = 0;
      p.vy = 0;
      p.moonCombo = 0;
      p.grounded = true;
      p.coyoteTimer = 0;
      p.jumpBufferTimer = 0;
      p.invulnTimer = 1.1;
      p.flapCd = 0;
      p.attackCd = 0;
      p.tunnelCd = 0;
      p.hp = 100;
      sv.energy = 100;
      sv.hydration = 100;
      sv.oxygen = 100;
      sv.tickDamageCd = 0;
      state.match.spawnShield = 4;
      state.match.respawnTimer = 0;
      state.match.streak = 0;
      state.objectiveStats.difficulty = 0;
      state.objectiveStats.lastDuration = 0;
      state.bots.length = 0;
      state.resources.length = 0;
      state.bosses.length = 0;
      state.bossSystem.cooldown = 6;
      for (let i = 0; i < BOT_TARGET; i++) spawnBot(i % 3 === 0 ? "air" : "ground");
      for (let i = 0; i < FOOD_TARGET; i++) spawnResource(i % 2 === 0 ? "tree" : "floor");
      setNextObjective("silent");
      showToast("Tester respawn");
    }

    function updatePlayer(dt) {
      const p = state.player;
      const perks = tierPerkProfile(p.tier);
      p.invulnTimer = Math.max(0, p.invulnTimer - dt);
      p.flapCd = Math.max(0, p.flapCd - dt);
      const speedBase = isAirTier(p.tier) ? MOVEMENT.airMax : MOVEMENT.landMax;
      const speed = speedBase * survivalSpeedMultiplier() * perks.speedBoost * speedUpgradeMultiplier();
      const dash = isActionPressed("sprint")
        ? (isAirTier(p.tier) ? 1.1 : MOVEMENT.sprintMult)
        : 1;
      const wantsJump = state.input.jumpQueued;
      state.input.jumpQueued = false;
      p.jumpBufferTimer = wantsJump ? MOVEMENT.jumpBufferTime : Math.max(0, p.jumpBufferTimer - dt);

      const dirX = (isActionPressed("moveRight") ? 1 : 0) -
        (isActionPressed("moveLeft") ? 1 : 0);
      if (dirX !== 0) p.facing = dirX;

      const groundAtFeet = groundY(p.x);
      p.grounded = !isAirTier(p.tier) && p.y >= groundAtFeet - 2;
      p.coyoteTimer = p.grounded ? MOVEMENT.coyoteTime : Math.max(0, p.coyoteTimer - dt);

      if (isAirTier(p.tier)) {
        const holdingUp = jumpHeld();
        const holdingDown = downHeld();
        const absDir = Math.abs(dirX);
        const targetVx = dirX * speed * dash * (holdingUp ? 0.95 : 0.88);
        const xResponse = absDir > 0 ? MOVEMENT.airAccelResponse : MOVEMENT.airBrakeResponse;
        p.vx += (targetVx - p.vx) * (1 - Math.exp(-xResponse * dt));
        if (absDir > 0 && Math.sign(targetVx) !== Math.sign(p.vx)) {
          p.vx += (targetVx - p.vx) * (1 - Math.exp(-MOVEMENT.airTurnResponse * dt));
        }

        let targetVy = MOVEMENT.airSinkSpeed;
        if (holdingUp) {
          targetVy = absDir === 0 ? -MOVEMENT.airHoverClimbSpeed : -MOVEMENT.airClimbSpeed;
          if (p.y >= groundAtFeet - 6) {
            p.vy = Math.min(p.vy, -180);
          }
          if (p.flapCd <= 0) {
            const flapBase = isMoonTier(p.tier) ? 76 : 92;
            const flapBoost = absDir > 0 ? flapBase * 0.78 : flapBase;
            p.vy -= flapBoost;
            p.flapCd = 0.15;
          }
          if (p.vy > 0) p.vy -= MOVEMENT.airLiftBoost * dt;
        } else if (holdingDown) {
          targetVy = MOVEMENT.airDiveSpeed;
        }

        if (!holdingUp && !holdingDown && p.y > groundAtFeet - 120) {
          targetVy = Math.max(70, targetVy - MOVEMENT.airNearGroundAssist);
        }

        p.vy += (targetVy - p.vy) * (1 - Math.exp(-MOVEMENT.airVerticalResponse * dt));
        if (!holdingUp && !holdingDown && absDir > 0) {
          p.vy -= MOVEMENT.airForwardLift * dt * Math.min(1, Math.abs(p.vx) / speed);
        }

        // Moon 1 gets a spectral glide profile (reaper-like drift).
        if (p.tier === 30) {
          const specterFloat = Math.sin(state.lastTime * 0.0032) * 24;
          p.vx *= 0.992;
          p.vy += (specterFloat - p.vy) * (1 - Math.exp(-1.5 * dt));
          if (holdingUp) p.vy -= 30 * dt;
          if (holdingDown) p.vy += 45 * dt;
        }
        p.vy = clamp(p.vy, -MOVEMENT.airVerticalMax, MOVEMENT.airVerticalMax);
      } else {
        const groundTargetVx = dirX * speed * dash;
        const groundResponse = dirX !== 0
          ? (MOVEMENT.accelGround / 240)
          : MOVEMENT.frictionGround;
        p.vx += (groundTargetVx - p.vx) * (1 - Math.exp(-groundResponse * dt));

        if (p.jumpBufferTimer > 0 && p.coyoteTimer > 0) {
          p.vy = -MOVEMENT.jumpSpeed;
          p.jumpBufferTimer = 0;
          p.coyoteTimer = 0;
          p.grounded = false;
        }

        let gravity = MOVEMENT.gravity;
        if (p.vy > 0) gravity *= MOVEMENT.fallGravityMult;
        p.vy += gravity * dt;

        if (!jumpHeld() && p.vy < 0) {
          p.vy += MOVEMENT.gravity * MOVEMENT.jumpCutMult * dt;
        }
        p.vy = Math.min(p.vy, MOVEMENT.maxFall);
      }

      p.vx = clamp(p.vx, -speed * dash, speed * dash);
      if (state.worldEvent.type === "Storm Wind") {
        const stormPush = state.settings.reduceMotion ? 18 : 30;
        p.vx += Math.sin((Date.now() + p.x * 0.02) * 0.0022) * stormPush * dt;
      }

      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.x = clamp(p.x, 20, WORLD.width - 20);

      if (!isAirTier(p.tier)) {
        const ground = groundY(p.x);
        if (p.y > ground) {
          p.y = ground;
          p.vy = 0;
          p.grounded = true;
        } else if (ground - p.y < 4 && p.vy >= 0) {
          p.y = ground;
          p.vy = 0;
        }
      } else {
        const ground = groundY(p.x);
        if (p.y > ground) {
          p.y = ground;
          p.vy = 0;
        }
        p.y = clamp(p.y, 80, WORLD.height - 40);
      }

      if (p.attackCd > 0) p.attackCd -= 1;
      if (p.tunnelCd > 0) p.tunnelCd -= 1;
      handleIceTunnel();
      syncCamera(dt);
    }

    function handleIceTunnel() {
      const p = state.player;
      const entranceTop = groundY(TUNNEL.entranceX + TUNNEL.entranceW * 0.5) - TUNNEL.entranceH;
      const insideEntrance =
        p.x >= TUNNEL.entranceX &&
        p.x <= TUNNEL.entranceX + TUNNEL.entranceW &&
        p.y >= entranceTop &&
        p.y <= entranceTop + TUNNEL.entranceH + 18;
      const entering = downHeld() || jumpHeld();

      if (insideEntrance && entering && p.tunnelCd <= 0) {
        p.x = TUNNEL.exitX;
        p.y = groundY(TUNNEL.exitX) - 8;
        p.vx = 0;
        p.vy = 0;
        p.tunnelCd = 70;
        showToast("Ice tunnel -> crossed to other side");
      }
    }

    function attackMoonBlade() {
      const p = state.player;
      if (!isMoonTier(p.tier) || p.attackCd > 0) return;
      const perks = tierPerkProfile(p.tier);
      p.attackCd = 26;
      playSfx("slash");
      const facingAngle = p.facing >= 0 ? 0 : Math.PI;
      const swingHalfAngle = 1.16;
      const inSwingCone = (tx, ty) => {
        const ang = Math.atan2(ty - p.y, tx - p.x);
        const delta = Math.atan2(Math.sin(ang - facingAngle), Math.cos(ang - facingAngle));
        return Math.abs(delta) <= swingHalfAngle;
      };
      let hits = 0;
      for (let i = state.bots.length - 1; i >= 0; i--) {
        const b = state.bots[i];
        const dist = Math.hypot(b.x - p.x, b.y - p.y);
        if (dist < 185 && inSwingCone(b.x, b.y) && canConsume(p.tier, b.tier)) {
          state.bots.splice(i, 1);
          registerEat(b, 25 + p.moonCombo * 6);
          hits++;
        }
      }
      for (let i = state.bosses.length - 1; i >= 0; i--) {
        const b = state.bosses[i];
        const dist = Math.hypot(b.x - p.x, b.y - p.y);
        if (dist < 230 && inSwingCone(b.x, b.y) && canConsume(p.tier, b.tier)) {
          const dmg = Math.floor((240 + p.moonCombo * 18) * perks.moonPower * moonDamageMultiplier());
          b.hp -= dmg;
          b.hitCd = 0.24;
          addObjectiveProgress("boss_hit", 1);
          hits++;
          if (b.hp <= 0) {
            rewardBossDefeat(b);
            state.bosses.splice(i, 1);
          }
        }
      }
      if (hits > 0) {
        p.moonCombo = Math.min(6, p.moonCombo + 1);
        applyImpactFx(0.85, 0.18, 0.013);
        showToast(`Moon Blade hit x${hits}`);
      } else {
        p.moonCombo = Math.max(0, p.moonCombo - 1);
        p.xp += 4;
        applyImpactFx(0.26, 0.06, 0.004);
        showToast("Moon Slash");
      }
    }

    function sendNetworkState(dt) {
      if (!state.net.connected || !state.net.socket || state.net.socket.readyState !== WebSocket.OPEN) return;
      state.netSendTimer -= dt;
      if (state.netSendTimer > 0) return;
      state.netSendTimer = 0.075;
      const p = state.player;
      state.net.socket.send(JSON.stringify({
        type: "state",
        x: p.x,
        y: p.y,
        tier: p.tier,
        name: ui.playerName.value.trim() || "Guest"
      }));
    }

    function performEatBurst(range, bonusXp) {
      const p = state.player;
      let ate = 0;
      for (let i = state.bots.length - 1; i >= 0; i--) {
        const b = state.bots[i];
        const dist = Math.hypot(b.x - p.x, b.y - p.y);
        if (dist <= range && canConsume(p.tier, b.tier)) {
          state.bots.splice(i, 1);
          registerEat(b, bonusXp);
          ate++;
        }
      }
      if (ate > 0) showToast(`Ability ate ${ate}`);
    }

    function castDashBite() {
      if (state.match.respawnTimer > 0) return;
      const p = state.player;
      const ab = state.abilities.q;
      const perks = tierPerkProfile(p.tier);
      if (ab.cd > 0) return;
      if (state.survival.energy < 9) {
        showToast("Low energy");
        return;
      }
      const isEarly = p.tier <= 8;
      const isMoon = p.tier >= 28;
      ab.cd = (isMoon ? ab.max * 0.72 : (isEarly ? ab.max * 0.9 : ab.max)) * perks.cooldownMult;
      state.survival.energy = Math.max(0, state.survival.energy - 9);
      p.vx += p.facing * (isMoon ? 430 : 360);
      performEatBurst(isMoon ? 150 : 120, isMoon ? 34 : 20);
      applyImpactFx(0.55, 0.11, 0.008);
      playSfx("dash");
      showToast("Dash Bite");
    }

    function castSonicCry() {
      if (state.match.respawnTimer > 0) return;
      const p = state.player;
      const ab = state.abilities.e;
      const perks = tierPerkProfile(p.tier);
      if (ab.cd > 0) return;
      if (state.survival.energy < 11) {
        showToast("Low energy");
        return;
      }
      const isAir = isAirTier(p.tier);
      ab.cd = (isAir ? ab.max * 0.85 : ab.max) * perks.cooldownMult;
      state.survival.energy = Math.max(0, state.survival.energy - 11);
      performEatBurst(isAir ? 190 : 165, isAir ? 24 : 16);
      for (const b of state.bots) {
        const dx = b.x - state.player.x;
        const dy = b.y - state.player.y;
        const d = Math.max(40, Math.hypot(dx, dy));
        if (d < 240) {
          b.vx += (dx / d) * 2.1;
          b.vy += (dy / d) * 1.8;
        }
      }
      applyImpactFx(0.48, 0.09, 0.006);
      playSfx("sonic");
      showToast("Sonic Cry");
    }

    function castRegen() {
      if (state.match.respawnTimer > 0) return;
      const p = state.player;
      const ab = state.abilities.f;
      const perks = tierPerkProfile(p.tier);
      if (ab.cd > 0) return;
      if (state.survival.hydration < 10) {
        showToast("Need hydration");
        return;
      }
      const isLate = p.tier >= 20;
      ab.cd = (isLate ? ab.max * 0.8 : ab.max) * perks.cooldownMult;
      state.survival.hydration = Math.max(0, state.survival.hydration - 10);
      state.player.hp = Math.min(100, state.player.hp + (isLate ? 44 : 34));
      state.player.xp += isLate ? 24 : 18;
      state.survival.oxygen = clamp(state.survival.oxygen + 8, 0, 100);
      applyImpactFx(0.42, 0.08, 0);
      playSfx("regen");
      showToast("Regen");
    }

    function updateBots(dt) {
      const p = state.player;
      if (state.match.spawnShield > 0) {
        maintainPopulation();
        return;
      }
      const timeScale = dt * 60;
      for (let i = state.bots.length - 1; i >= 0; i--) {
        const b = state.bots[i];
        const fly = isAirTier(b.tier);
        if (Math.abs(b.x - p.x) > 3400) {
          state.bots.splice(i, 1);
          continue;
        }

        const dx = p.x - b.x;
        const dy = p.y - b.y;
        const dist = Math.max(1, Math.hypot(dx, dy));
        const preyOfPlayer = canConsume(p.tier, b.tier);
        const hunter = !preyOfPlayer && canConsume(b.tier, p.tier);
        const seed = b.behaviorSeed || 0;
        const jitterX = Math.sin(state.lastTime * 0.0013 + seed + i) * (fly ? 0.4 : 0.22);
        let targetVx = b.vx;

        if (preyOfPlayer && dist < 1200) {
          const fleeSpeed = fly ? 2.7 : 2.2;
          targetVx = -Math.sign(dx || 1) * fleeSpeed + jitterX * 0.4;
        } else if (hunter && dist < 1400) {
          const chaseSpeed = fly ? 3.0 : 2.45;
          targetVx = Math.sign(dx || 1) * chaseSpeed + jitterX * 0.35;
        } else {
          targetVx = b.vx * 0.92 + jitterX;
        }

        b.vx += (targetVx - b.vx) * (1 - Math.exp(-2.35 * dt));
        if (fly) {
          let targetVy = b.vy * 0.84 + Math.cos(state.lastTime * 0.0011 + seed) * 0.18;
          if (preyOfPlayer && dist < 1000) targetVy += -Math.sign(dy || 1) * 1.1;
          if (hunter && dist < 1100) targetVy += Math.sign(dy || 1) * 1.2;
          b.vy += (targetVy - b.vy) * (1 - Math.exp(-2.1 * dt));
        } else {
          const g = groundY(b.x);
          if (b.y >= g - 1) {
            b.y = g;
            b.vy = 0;
            if (hunter && dist < 460 && Math.random() < dt * 2.8) {
              b.vy = -520;
            }
          } else {
            b.vy += MOVEMENT.gravity * 0.4 * dt;
            b.vy = Math.min(b.vy, 620);
          }
        }

        b.x += b.vx * timeScale;
        b.y += b.vy * timeScale;

        if (b.x < 20 || b.x > WORLD.width - 20) b.vx *= -1;
        if (fly) {
          if (b.y < 90 || b.y > WORLD.height - 40) b.vy *= -1;
        } else {
          const g = groundY(b.x);
          if (b.y >= g) {
            b.y = g;
            b.vy = 0;
          } else {
            b.vy += 0.24 * timeScale;
          }
        }

        const postDist = Math.hypot(b.x - p.x, b.y - p.y);
        const collision = postDist < p.size * 0.55 + b.size * 0.55;
        if (collision) {
          if (canConsume(p.tier, b.tier)) {
            state.bots.splice(i, 1);
            registerEat(b, 0);
          } else if (b.tier > p.tier && b.tier - p.tier <= 4) {
            if (p.invulnTimer <= 0 && state.match.spawnShield <= 0) {
              const hit = Math.max(9, Math.floor((8 + (b.tier - p.tier) * 4) * damageTakenMultiplier()));
              p.hp -= hit;
              p.invulnTimer = 0.85;
              addCombatText(p.x, p.y - p.size * 0.6, `-${hit}`, "#ff8e8e", 16);
              p.vx += Math.sign(p.x - b.x || 1) * 140;
              p.vy = Math.min(p.vy, -190);
              applyImpactFx(0.58, 0.16, 0.008);
              if (p.hp <= 0) {
                resetIfDefeated(`tier ${b.tier}`);
                break;
              }
            }
          }
        }
      }
      maintainPopulation();
    }

    function drawBiomeBackdropLayers(biome, nightMix) {
      const palettes = {
        Greenwood: {
          far: "rgba(156,187,214,0.42)",
          mid: "rgba(121,154,186,0.37)",
          near: "rgba(95,128,160,0.32)",
          mist: "rgba(210,236,247,0.15)"
        },
        "Amber Dunes": {
          far: "rgba(204,173,134,0.35)",
          mid: "rgba(178,144,100,0.33)",
          near: "rgba(144,110,73,0.31)",
          mist: "rgba(250,223,173,0.13)"
        },
        "Frost Reach": {
          far: "rgba(178,208,228,0.42)",
          mid: "rgba(141,176,203,0.36)",
          near: "rgba(108,149,178,0.33)",
          mist: "rgba(220,246,255,0.16)"
        },
        "Ash Ridge": {
          far: "rgba(136,132,152,0.42)",
          mid: "rgba(118,110,134,0.35)",
          near: "rgba(96,88,109,0.34)",
          mist: "rgba(201,182,170,0.13)"
        }
      };
      const p = palettes[biome.name] || palettes.Greenwood;
      const layers = [
        { base: 0.38, amp1: 56, amp2: 26, f1: 0.0012, f2: 0.00054, parallax: 0.08, color: p.far },
        { base: 0.5, amp1: 46, amp2: 18, f1: 0.0021, f2: 0.0011, parallax: 0.16, color: p.mid },
        { base: 0.6, amp1: 34, amp2: 14, f1: 0.0032, f2: 0.0018, parallax: 0.28, color: p.near }
      ];

      for (const layer of layers) {
        ctx.fillStyle = layer.color;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x = 0; x <= canvas.width + 24; x += 16) {
          const wx = x + state.camera.x * layer.parallax;
          const y = canvas.height * layer.base
            - Math.sin(wx * layer.f1) * layer.amp1
            - Math.cos(wx * layer.f2) * layer.amp2;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();
      }

      const mist = ctx.createLinearGradient(0, canvas.height * 0.45, 0, canvas.height * 0.76);
      mist.addColorStop(0, p.mist);
      mist.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = mist;
      ctx.fillRect(0, canvas.height * 0.44, canvas.width, canvas.height * 0.34);

      const horizonGlow = ctx.createLinearGradient(0, canvas.height * 0.58, 0, canvas.height);
      horizonGlow.addColorStop(0, `rgba(255,255,255,${0.06 - nightMix * 0.03})`);
      horizonGlow.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = horizonGlow;
      ctx.fillRect(0, canvas.height * 0.56, canvas.width, canvas.height * 0.22);
    }

    function drawWorld() {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      const dayWave = Math.sin(state.visual.dayPhase * Math.PI * 2);
      const nightMix = Math.max(0, (-dayWave + 0.25) / 1.25);
      const biome = biomeAtX(state.player.x);
      const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGrad.addColorStop(0, nightMix > 0.2 ? "#1b2f49" : biome.skyTop);
      skyGrad.addColorStop(0.34, nightMix > 0.2 ? "#345678" : biome.skyMid);
      skyGrad.addColorStop(0.62, nightMix > 0.2 ? "#577696" : biome.skyLow);
      skyGrad.addColorStop(0.63, "#78ad78");
      skyGrad.addColorStop(1, "#40643d");
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const sunX = canvas.width * 0.78;
      const sunY = canvas.height * 0.16;
      const sunGlow = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, 170);
      sunGlow.addColorStop(0, "rgba(255,244,198,0.92)");
      sunGlow.addColorStop(1, "rgba(255,244,198,0)");
      ctx.fillStyle = sunGlow;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawLightRays(sunX, sunY);
      if (nightMix > 0.08) {
        ctx.fillStyle = `rgba(10,20,40,${0.2 + nightMix * 0.3})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const starCount = Math.floor(16 + nightMix * 26);
        ctx.fillStyle = "rgba(230,240,255,0.75)";
        for (let i = 0; i < starCount; i++) {
          const sx = (i * 73 + (state.camera.x * 0.08) % (canvas.width + 120)) % canvas.width;
          const sy = 28 + ((i * 41) % Math.floor(canvas.height * 0.45));
          ctx.fillRect(sx, sy, 1.5, 1.5);
        }
      }

      drawBiomeBackdropLayers(biome, nightMix);

      drawSkyIslands();
      drawForestLayers();
      drawWaterLayer(nightMix);

      if (state.worldEvent.type === "Storm Wind") {
        ctx.fillStyle = "rgba(70,90,120,0.12)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        for (let i = 0; i < 6; i++) {
          const y = (i * 92 + Date.now() * 0.06) % canvas.height;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y - 10);
          ctx.stroke();
        }
      } else if (state.worldEvent.type === "Frenzy Hunt") {
        ctx.fillStyle = "rgba(255,90,90,0.1)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      const t = Date.now() * 0.015;
      ctx.globalAlpha = 0.24;
      const cloudBase = state.quality === "ultra" ? 26 : (state.quality === "high" ? 18 : 10);
      const cloudCount = state.settings.reduceMotion ? Math.floor(cloudBase * 0.55) : cloudBase;
      for (let i = 0; i < cloudCount; i++) {
        const speed = 0.42 + (i % 5) * 0.07;
        const cx = ((i * 240 + t * speed) % (WORLD.width + 460)) - state.camera.x - 120;
        const cy = 62 + (i % 5) * 26;
        ctx.fillStyle = i % 2 === 0 ? "rgba(255,255,255,0.82)" : "rgba(242,249,255,0.68)";
        ctx.beginPath();
        ctx.ellipse(cx, cy, 24 + (i % 4) * 6, 10 + (i % 3) * 2, 0, 0, Math.PI * 2);
        ctx.ellipse(cx + 22, cy + 2, 19 + (i % 4) * 5, 9 + (i % 2) * 2, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Atmospheric horizon haze
      const haze = ctx.createLinearGradient(0, canvas.height * 0.5, 0, canvas.height * 0.75);
      haze.addColorStop(0, "rgba(225,246,255,0.1)");
      haze.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = haze;
      ctx.fillRect(0, canvas.height * 0.48, canvas.width, canvas.height * 0.24);

      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let sx = 0; sx <= canvas.width + 10; sx += 20) {
        const wx = sx + state.camera.x;
        const gy = groundY(wx) - state.camera.y;
        if (sx === 0) ctx.moveTo(sx, gy);
        else ctx.lineTo(sx, gy);
      }
      ctx.stroke();

      const groundGrad = ctx.createLinearGradient(0, canvas.height * 0.58, 0, canvas.height);
      groundGrad.addColorStop(0, biome.groundTop);
      groundGrad.addColorStop(1, biome.groundBottom);
      ctx.fillStyle = groundGrad;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      for (let sx = 0; sx <= canvas.width + 10; sx += 20) {
        const wx = sx + state.camera.x;
        ctx.lineTo(sx, groundY(wx) - state.camera.y);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.closePath();
      ctx.fill();
      drawGroundTexture();
      drawGroundBlocks();

      // Ground top trim and subtle depth
      ctx.strokeStyle = "rgba(190,242,158,0.44)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let sx = 0; sx <= canvas.width + 10; sx += 20) {
        const wx = sx + state.camera.x;
        const gy = groundY(wx) - state.camera.y;
        if (sx === 0) ctx.moveTo(sx, gy);
        else ctx.lineTo(sx, gy);
      }
      ctx.stroke();
      drawLandmarks();
      drawZoneMarkers();
      drawHazardZones();
      drawRevengeMarker();
      drawRockProps();
      drawGroundDecor();
      drawWindGrass(nightMix);
      drawAmbientParticles(nightMix);
      drawForegroundSilhouettes();

      // Soil grain dots
      ctx.fillStyle = "rgba(36,53,29,0.13)";
      for (let i = 0; i < 74; i++) {
        const px = (i * 97 + (state.camera.x * 0.07) % 1000) % canvas.width;
        const py = canvas.height * 0.73 + (i * 37) % (canvas.height * 0.27);
        ctx.fillRect(px, py, 2, 2);
      }

      // Vignette to add contrast focus
      const vignette = ctx.createRadialGradient(
        canvas.width * 0.5,
        canvas.height * 0.5,
        canvas.height * 0.2,
        canvas.width * 0.5,
        canvas.height * 0.5,
        canvas.width * 0.75
      );
      vignette.addColorStop(0, "rgba(0,0,0,0)");
      vignette.addColorStop(1, "rgba(0,0,0,0.09)");
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Subtle color grade pass
      ctx.fillStyle = nightMix > 0.2 ? "rgba(35,56,88,0.1)" : "rgba(255,208,120,0.02)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawFilmGrain();

      const entranceTop = groundY(TUNNEL.entranceX + TUNNEL.entranceW * 0.5) - TUNNEL.entranceH;
      const tunnelScreen = worldToScreen(TUNNEL.entranceX, entranceTop);
      if (
        tunnelScreen.x < canvas.width + 80 &&
        tunnelScreen.x + TUNNEL.entranceW > -80 &&
        tunnelScreen.y < canvas.height + 40
      ) {
        ctx.fillStyle = "rgba(155, 238, 255, 0.8)";
        ctx.fillRect(tunnelScreen.x, tunnelScreen.y, TUNNEL.entranceW, TUNNEL.entranceH);
        ctx.strokeStyle = "rgba(220, 250, 255, 0.9)";
        ctx.lineWidth = 3;
        ctx.strokeRect(tunnelScreen.x, tunnelScreen.y, TUNNEL.entranceW, TUNNEL.entranceH);

        ctx.fillStyle = "#0f3752";
        ctx.font = "12px Trebuchet MS";
        ctx.textAlign = "center";
        ctx.fillText("ICE TUNNEL", tunnelScreen.x + TUNNEL.entranceW * 0.5, tunnelScreen.y + 30);
        ctx.fillText("Press S / Down / Space", tunnelScreen.x + TUNNEL.entranceW * 0.5, tunnelScreen.y + 50);
      }
    }

    function drawGroundBlocks() {
      const tileW = 68;
      const tileH = 38;
      for (let sx = -tileW; sx < canvas.width + tileW; sx += tileW) {
        const wx = sx + state.camera.x;
        const biome = biomeAtX(wx).name;
        let line = "rgba(20,26,24,0.22)";
        let crack = "rgba(255,255,255,0.06)";
        let moss = "rgba(128,182,78,0.18)";
        if (biome === "Amber Dunes") {
          line = "rgba(76,56,30,0.25)";
          crack = "rgba(255,224,160,0.08)";
          moss = "rgba(198,170,80,0.15)";
        } else if (biome === "Frost Reach") {
          line = "rgba(45,68,88,0.28)";
          crack = "rgba(218,246,255,0.13)";
          moss = "rgba(122,202,220,0.13)";
        } else if (biome === "Ash Ridge") {
          line = "rgba(56,48,45,0.3)";
          crack = "rgba(220,160,145,0.08)";
          moss = "rgba(132,88,72,0.14)";
        }
        const gy = groundY(wx) - state.camera.y;
        const top = gy + 16;
        if (top >= canvas.height) continue;
        const colShift = ((Math.floor(wx / tileW) % 2) + 2) % 2;
        ctx.strokeStyle = line;
        ctx.lineWidth = 1.3;
        for (let y = top; y < canvas.height; y += tileH) {
          const seamX = sx + (colShift === 0 ? 0 : tileW * 0.5);
          ctx.beginPath();
          ctx.moveTo(seamX, y);
          ctx.lineTo(seamX, Math.min(canvas.height, y + tileH));
          ctx.stroke();

          ctx.strokeStyle = crack;
          ctx.beginPath();
          ctx.moveTo(sx + 10, y + 10);
          ctx.lineTo(sx + 22, y + 14);
          ctx.moveTo(sx + 34, y + 7);
          ctx.lineTo(sx + 43, y + 13);
          ctx.stroke();
          ctx.strokeStyle = line;
          ctx.fillStyle = moss;
          ctx.fillRect(sx + 2, y + 2, tileW - 5, 3);
        }
      }
    }

    function drawAmbientParticles(nightMix) {
      const count = VISUALS.ambientParticles[state.quality] || VISUALS.ambientParticles.high;
      const biome = biomeAtX(state.player.x).name;
      const t = Date.now() * (state.settings.reduceMotion ? 0.0002 : 0.0007);
      let color = "rgba(228,244,202,0.33)";
      if (biome === "Amber Dunes") color = "rgba(244,210,148,0.3)";
      if (biome === "Frost Reach") color = "rgba(214,241,255,0.36)";
      if (biome === "Ash Ridge") color = "rgba(255,170,130,0.27)";
      for (let i = 0; i < count; i++) {
        const speed = 0.35 + (i % 7) * 0.08;
        const drift = (Math.sin(t * 4 + i * 0.7) * 12);
        const x = ((i * 151 + t * 950 * speed + state.camera.x * 0.08) % (canvas.width + 120)) - 60 + drift;
        const yBase = (i * 53) % (canvas.height - 110);
        const y = yBase + Math.sin(t * 3.2 + i * 1.1) * 8;
        const r = biome === "Frost Reach" ? 1.8 : (1 + (i % 3) * 0.45);
        ctx.fillStyle = color;
        ctx.globalAlpha = biome === "Ash Ridge" ? 0.35 + Math.sin(t * 5 + i) * 0.1 : 0.28 + nightMix * 0.2;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawForegroundSilhouettes() {
      const step = 220;
      const start = Math.floor(state.camera.x / step) - 2;
      const end = start + Math.ceil(canvas.width / step) + 4;
      ctx.save();
      ctx.globalAlpha = 0.25;
      for (let i = start; i <= end; i++) {
        const wx = i * step + 80;
        const sx = wx - state.camera.x * 1.02;
        const gy = groundY(wx) - state.camera.y;
        const h = 28 + (i % 4) * 10;
        const w = 34 + (i % 5) * 6;
        ctx.fillStyle = i % 3 === 0 ? "rgba(30,53,31,0.8)" : "rgba(26,44,28,0.7)";
        ctx.beginPath();
        ctx.ellipse(sx, gy - 8, w, h, 0, 0, Math.PI * 2);
        ctx.ellipse(sx - 14, gy - 11, w * 0.62, h * 0.76, 0, 0, Math.PI * 2);
        ctx.ellipse(sx + 15, gy - 10, w * 0.56, h * 0.72, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawFilmGrain() {
      if (state.quality === "medium") return;
      const dots = state.quality === "ultra" ? 180 : 110;
      ctx.fillStyle = "rgba(255,255,255,0.025)";
      for (let i = 0; i < dots; i++) {
        const x = (i * 73 + (Date.now() * 0.09) % 999) % canvas.width;
        const y = (i * 41 + (Date.now() * 0.07) % 777) % canvas.height;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    function drawForestLayers() {
      const step = 170;
      const viewMin = state.camera.x - 420;
      const viewMax = state.camera.x + canvas.width + 420;
      const start = Math.floor(viewMin / step) - 1;
      const end = Math.ceil(viewMax / step) + 1;
      const outline = "#10150e";

      ctx.save();
      ctx.globalAlpha = 0.84;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      for (let i = start; i <= end; i++) {
        const wx = i * step + 110;
        const x = wx - state.camera.x;
        if (x < -260 || x > canvas.width + 260) continue;
        const ground = groundY(wx) - state.camera.y;
        const scale = 0.7 + (Math.abs(Math.sin(i * 0.73)) * 0.38);
        const trunkH = 126 * scale;
        const trunkW = 22 * scale;
        const canopyR = 84 * scale;
        const trunkTopY = ground - trunkH;
        const lean = Math.sin(i * 1.37) * 16 * scale;

        // Trunk outline then trunk fill for chunky cartoon style.
        ctx.strokeStyle = outline;
        ctx.lineWidth = trunkW + 9;
        ctx.beginPath();
        ctx.moveTo(x, ground + 8);
        ctx.bezierCurveTo(
          x - 12 * scale,
          ground - trunkH * 0.35,
          x + lean,
          ground - trunkH * 0.76,
          x + lean * 0.5,
          trunkTopY
        );
        ctx.stroke();

        ctx.strokeStyle = "#6f4220";
        ctx.lineWidth = trunkW;
        ctx.beginPath();
        ctx.moveTo(x, ground + 8);
        ctx.bezierCurveTo(
          x - 11 * scale,
          ground - trunkH * 0.34,
          x + lean,
          ground - trunkH * 0.77,
          x + lean * 0.5,
          trunkTopY
        );
        ctx.stroke();

        // Branches.
        ctx.strokeStyle = outline;
        ctx.lineWidth = 8 * scale;
        ctx.beginPath();
        ctx.moveTo(x + lean * 0.32, ground - trunkH * 0.56);
        ctx.lineTo(x + 30 * scale + lean * 0.7, ground - trunkH * 0.68);
        ctx.moveTo(x + lean * 0.22, ground - trunkH * 0.64);
        ctx.lineTo(x - 26 * scale + lean * 0.1, ground - trunkH * 0.74);
        ctx.stroke();

        ctx.strokeStyle = "#6f4220";
        ctx.lineWidth = 5.2 * scale;
        ctx.beginPath();
        ctx.moveTo(x + lean * 0.32, ground - trunkH * 0.56);
        ctx.lineTo(x + 30 * scale + lean * 0.7, ground - trunkH * 0.68);
        ctx.moveTo(x + lean * 0.22, ground - trunkH * 0.64);
        ctx.lineTo(x - 26 * scale + lean * 0.1, ground - trunkH * 0.74);
        ctx.stroke();

        const cx = x + lean * 0.5;
        const cy = trunkTopY - canopyR * 0.12;

        // Spiky canopy shape with dark outline.
        const points = 26;
        ctx.beginPath();
        for (let p = 0; p <= points; p++) {
          const a = (p / points) * Math.PI * 2;
          const jag = 1
            + Math.sin(p * 2.3 + i * 1.2) * 0.13
            + Math.cos(p * 4.8 + i * 0.9) * 0.06;
          const rr = canopyR * jag;
          const px = cx + Math.cos(a) * rr;
          const py = cy + Math.sin(a) * rr * 0.9;
          if (p === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = "#97cb10";
        ctx.strokeStyle = outline;
        ctx.lineWidth = 6.4 * scale;
        ctx.fill();
        ctx.stroke();

        // Inner light leaf mass.
        ctx.beginPath();
        for (let p = 0; p <= points; p++) {
          const a = (p / points) * Math.PI * 2;
          const rr = canopyR * 0.77 * (1 + Math.sin(p * 2.1 + i * 1.9) * 0.08);
          const px = cx + Math.cos(a) * rr * 0.95;
          const py = cy - canopyR * 0.05 + Math.sin(a) * rr * 0.85;
          if (p === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = "rgba(197,246,43,0.85)";
        ctx.fill();

        // Dark leaf shadow pockets.
        ctx.fillStyle = "rgba(71,121,19,0.46)";
        for (let s = 0; s < 4; s++) {
          const sa = 0.8 + s * 1.4 + Math.sin(i * 0.4) * 0.18;
          const sx = cx + Math.cos(sa) * canopyR * 0.38;
          const sy = cy + Math.sin(sa) * canopyR * 0.3;
          ctx.beginPath();
          ctx.ellipse(sx, sy, 22 * scale, 14 * scale, sa * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }

        // Fruit clusters.
        const fruitCount = 3 + (i % 3);
        for (let f = 0; f < fruitCount; f++) {
          const fa = 0.3 + f * ((Math.PI * 2) / fruitCount) + Math.sin(i * 0.6) * 0.15;
          const fr = canopyR * (0.28 + ((f * 37) % 40) / 100);
          const fx = cx + Math.cos(fa) * fr;
          const fy = cy + Math.sin(fa) * fr * 0.85;
          ctx.strokeStyle = "#5d3918";
          ctx.lineWidth = 1.6 * scale;
          ctx.beginPath();
          ctx.moveTo(fx, fy - 9 * scale);
          ctx.lineTo(fx + 3 * scale, fy - 15 * scale);
          ctx.stroke();
          ctx.fillStyle = "#c61f49";
          ctx.beginPath();
          ctx.arc(fx - 4 * scale, fy, 5.2 * scale, 0, Math.PI * 2);
          ctx.arc(fx + 3.6 * scale, fy + 0.4 * scale, 5.4 * scale, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "rgba(255,160,190,0.55)";
          ctx.beginPath();
          ctx.arc(fx - 5 * scale, fy - 1.6 * scale, 1.6 * scale, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();
    }

    function drawSkyIslands() {
      const motion = state.settings.reduceMotion ? 0.2 : 1;
      const t = Date.now() * 0.00012 * motion;
      for (let i = 0; i < 6; i++) {
        const wx = state.camera.x * 0.12 + i * 490 + Math.sin(t + i * 1.7) * (18 * motion);
        const x = (wx % (canvas.width + 300)) - 140;
        const y = canvas.height * (0.18 + (i % 3) * 0.06);
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = "rgba(255,255,255,0.82)";
        ctx.beginPath();
        ctx.ellipse(x, y, 44, 14, 0, 0, Math.PI * 2);
        ctx.ellipse(x + 28, y + 3, 30, 11, 0, 0, Math.PI * 2);
        ctx.ellipse(x - 26, y + 4, 25, 10, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawWaterLayer(nightMix) {
      const mistY = canvas.height * 0.63;
      const mistGrad = ctx.createLinearGradient(0, mistY, 0, mistY + 70);
      mistGrad.addColorStop(0, nightMix > 0.2 ? "rgba(132,168,198,0.08)" : "rgba(210,232,241,0.1)");
      mistGrad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = mistGrad;
      ctx.fillRect(0, mistY, canvas.width, 70);

      ctx.strokeStyle = "rgba(255,255,255,0.07)";
      ctx.lineWidth = 1;
      for (let i = 0; i < 2; i++) {
        const y = mistY + i * 16;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function drawWindGrass(nightMix) {
      if (state.settings.reduceMotion) return;
      const time = Date.now() * 0.0012;
      const bladeCount = Math.floor(canvas.width / 13);
      ctx.strokeStyle = nightMix > 0.25 ? "rgba(122,182,127,0.2)" : "rgba(173,233,145,0.24)";
      ctx.lineWidth = 1;
      for (let i = 0; i < bladeCount; i++) {
        const sx = i * 13;
        const wx = sx + state.camera.x;
        const gy = groundY(wx) - state.camera.y;
        const sway = Math.sin(time + wx * 0.018) * 1.2;
        const h = 8 + ((i * 7) % 6);
        ctx.beginPath();
        ctx.moveTo(sx, gy + 1);
        ctx.lineTo(sx + sway, gy - h);
        ctx.stroke();
      }
    }

    function drawLightRays(sunX, sunY) {
      if (state.settings.reduceMotion) return;
      ctx.save();
      ctx.translate(sunX, sunY);
      ctx.globalAlpha = 0.04;
      for (let i = 0; i < 8; i++) {
        ctx.rotate(0.24);
        const ray = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.85);
        ray.addColorStop(0, "rgba(255,241,190,0.34)");
        ray.addColorStop(1, "rgba(255,241,190,0)");
        ctx.fillStyle = ray;
        ctx.beginPath();
        ctx.moveTo(-18, 0);
        ctx.lineTo(18, 0);
        ctx.lineTo(86, canvas.height * 0.62);
        ctx.lineTo(-86, canvas.height * 0.62);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function drawRockProps() {
      const step = 240;
      const start = Math.floor(state.camera.x / step) - 2;
      const end = start + Math.ceil(canvas.width / step) + 4;
      for (let i = start; i <= end; i++) {
        if (i % 2 !== 0) continue;
        const wx = i * step + 120;
        const sx = wx - state.camera.x;
        const gy = groundY(wx) - state.camera.y;
        const biome = biomeAtX(wx).name;
        if (biome === "Amber Dunes") {
          ctx.fillStyle = "rgba(172,132,64,0.62)";
          ctx.beginPath();
          ctx.ellipse(sx, gy - 4, 28, 10, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(120,85,32,0.52)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(sx - 18, gy - 4);
          ctx.lineTo(sx + 18, gy - 4);
          ctx.stroke();
          if (i % 4 === 0) {
            ctx.strokeStyle = "#2e6c37";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(sx, gy + 2);
            ctx.lineTo(sx, gy - 24);
            ctx.moveTo(sx - 5, gy - 15);
            ctx.lineTo(sx - 10, gy - 8);
            ctx.moveTo(sx + 5, gy - 13);
            ctx.lineTo(sx + 10, gy - 6);
            ctx.stroke();
          }
          continue;
        }
        if (biome === "Frost Reach") {
          ctx.fillStyle = "rgba(168,220,246,0.66)";
          ctx.strokeStyle = "rgba(70,140,176,0.7)";
          ctx.lineWidth = 1.6;
          ctx.beginPath();
          ctx.moveTo(sx, gy - 24);
          ctx.lineTo(sx + 12, gy + 2);
          ctx.lineTo(sx - 12, gy + 2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          continue;
        }
        if (biome === "Ash Ridge") {
          ctx.fillStyle = "rgba(72,60,58,0.75)";
          ctx.beginPath();
          ctx.moveTo(sx - 12, gy + 2);
          ctx.lineTo(sx - 5, gy - 18);
          ctx.lineTo(sx + 4, gy - 12);
          ctx.lineTo(sx + 12, gy + 2);
          ctx.closePath();
          ctx.fill();
          continue;
        }
        const h = 22 + (i % 5) * 6;
        const w = 28 + (i % 4) * 7;
        ctx.fillStyle = "rgba(78,96,92,0.55)";
        ctx.beginPath();
        ctx.moveTo(sx - w * 0.5, gy + 2);
        ctx.lineTo(sx - w * 0.3, gy - h * 0.45);
        ctx.lineTo(sx, gy - h);
        ctx.lineTo(sx + w * 0.42, gy - h * 0.35);
        ctx.lineTo(sx + w * 0.5, gy + 2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "rgba(32,46,45,0.45)";
        ctx.lineWidth = 1.4;
        ctx.stroke();
      }
    }

    function drawGroundDecor() {
      const step = 95;
      const viewMin = state.camera.x - 140;
      const viewMax = state.camera.x + canvas.width + 140;
      const start = Math.floor(viewMin / step) - 1;
      const end = Math.ceil(viewMax / step) + 1;
      for (let i = start; i <= end; i++) {
        const wx = i * step + 70;
        const sx = wx - state.camera.x;
        const gy = groundY(wx) - state.camera.y;
        const mode = ((i % 7) + 7) % 7;
        const biome = biomeAtX(wx).name;
        if (mode === 0 || mode === 4) {
          const dark = biome === "Amber Dunes" ? "#4e5a1e" : (biome === "Ash Ridge" ? "#2a2f2a" : "#0f1c11");
          const light = biome === "Amber Dunes" ? "#a6ba3a" : (biome === "Frost Reach" ? "#8ad7dd" : (mode === 0 ? "#58ba42" : "#7fd63f"));
          ctx.fillStyle = dark;
          ctx.beginPath();
          ctx.arc(sx, gy - 11, 14, 0, Math.PI * 2);
          ctx.arc(sx - 13, gy - 9, 10, 0, Math.PI * 2);
          ctx.arc(sx + 12, gy - 8, 9, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = light;
          ctx.beginPath();
          ctx.arc(sx, gy - 12, 11, 0, Math.PI * 2);
          ctx.arc(sx - 10, gy - 10, 8, 0, Math.PI * 2);
          ctx.arc(sx + 9, gy - 9, 7, 0, Math.PI * 2);
          ctx.fill();
          continue;
        }

        if (mode === 1 || mode === 5) {
          // Flower pair.
          ctx.strokeStyle = biome === "Amber Dunes" ? "#6e7a3a" : "#33693a";
          ctx.lineWidth = 2.2;
          ctx.beginPath();
          ctx.moveTo(sx - 4, gy + 1);
          ctx.lineTo(sx - 4, gy - 16);
          ctx.moveTo(sx + 5, gy + 1);
          ctx.lineTo(sx + 5, gy - 14);
          ctx.stroke();
          const petals = biome === "Frost Reach"
            ? "#8fe8ff"
            : (mode === 1 ? "#f14fff" : "#ffd535");
          ctx.fillStyle = "#121212";
          ctx.beginPath();
          ctx.arc(sx - 4, gy - 18, 7.5, 0, Math.PI * 2);
          ctx.arc(sx + 5, gy - 16, 6.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = petals;
          ctx.beginPath();
          ctx.arc(sx - 4, gy - 18, 5.4, 0, Math.PI * 2);
          ctx.arc(sx + 5, gy - 16, 4.6, 0, Math.PI * 2);
          ctx.fill();
          continue;
        }

        if (mode === 2) {
          // Tiny stump.
          ctx.fillStyle = biome === "Frost Reach" ? "#5e7d89" : "#2e1e15";
          ctx.fillRect(sx - 6, gy - 9, 12, 10);
          ctx.fillStyle = biome === "Frost Reach" ? "#8fc2d2" : "#8c5a2f";
          ctx.fillRect(sx - 4, gy - 8, 8, 8);
          continue;
        }

        if (mode === 3) {
          // Pebble.
          ctx.fillStyle = "rgba(70,76,76,0.78)";
          ctx.beginPath();
          ctx.ellipse(sx, gy - 2, 7, 4.5, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawLandmarks() {
      const pulse = 1 + Math.sin(state.lastTime * 0.0024) * 0.08;
      for (const lm of landmarkDefs) {
        if (Math.abs(lm.x - state.camera.x - canvas.width * 0.5) > canvas.width * 0.9) continue;
        const sx = lm.x - state.camera.x;
        const gy = groundY(lm.x) - state.camera.y;
        if (sx < -170 || sx > canvas.width + 170) continue;

        ctx.save();
        ctx.globalAlpha = 0.92;
        ctx.strokeStyle = "rgba(10,18,26,0.75)";
        ctx.lineWidth = 3;
        ctx.fillStyle = "rgba(233,244,255,0.16)";
        ctx.beginPath();
        ctx.ellipse(sx, gy - 6, 52 * pulse, 16, 0, 0, Math.PI * 2);
        ctx.fill();

        if (lm.type === "orchard" || lm.type === "moon") {
          ctx.strokeStyle = "#17220d";
          ctx.lineWidth = 9;
          ctx.beginPath();
          ctx.moveTo(sx, gy + 2);
          ctx.lineTo(sx, gy - 84);
          ctx.stroke();
          ctx.fillStyle = lm.type === "moon" ? "#cadc7f" : "#98cb14";
          ctx.beginPath();
          ctx.arc(sx, gy - 110, 44, 0, Math.PI * 2);
          ctx.fill();
          if (lm.type === "moon") {
            ctx.strokeStyle = "#f8efb4";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx + 2, gy - 114, 18, -1.2, 1.2);
            ctx.stroke();
          }
        } else if (lm.type === "ruins" || lm.type === "grave") {
          ctx.fillStyle = lm.type === "grave" ? "#52535f" : "#747f8f";
          ctx.fillRect(sx - 34, gy - 68, 68, 62);
          ctx.strokeStyle = "#1e2732";
          ctx.lineWidth = 4;
          ctx.strokeRect(sx - 34, gy - 68, 68, 62);
          ctx.fillStyle = "rgba(230,240,255,0.35)";
          ctx.fillRect(sx - 28, gy - 60, 18, 18);
          ctx.fillRect(sx + 10, gy - 60, 18, 18);
        } else if (lm.type === "crystal" || lm.type === "frost") {
          ctx.fillStyle = lm.type === "frost" ? "#9fe8ff" : "#9b7cff";
          ctx.beginPath();
          ctx.moveTo(sx, gy - 96);
          ctx.lineTo(sx + 30, gy - 10);
          ctx.lineTo(sx - 30, gy - 10);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "#16354a";
          ctx.lineWidth = 3;
          ctx.stroke();
        } else {
          ctx.strokeStyle = "#2f3d4f";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(sx - 26, gy - 38);
          ctx.lineTo(sx + 26, gy - 38);
          ctx.moveTo(sx, gy - 60);
          ctx.lineTo(sx, gy - 10);
          ctx.stroke();
        }

        ctx.fillStyle = "rgba(7,18,30,0.86)";
        ctx.strokeStyle = "rgba(173,214,246,0.55)";
        ctx.lineWidth = 2;
        ctx.fillRect(sx - 62, gy - 132, 124, 20);
        ctx.strokeRect(sx - 62, gy - 132, 124, 20);
        ctx.fillStyle = "#e8f5ff";
        ctx.font = "bold 11px Trebuchet MS";
        ctx.textAlign = "center";
        ctx.fillText(lm.name, sx, gy - 118);
        ctx.restore();
      }
    }

    function drawRevengeMarker() {
      const d = state.death;
      if (!d.revengeActive || d.lastX == null || d.lastY == null) return;
      if (!inView(d.lastX, d.lastY, 130)) return;
      const s = worldToScreen(d.lastX, d.lastY);
      const pulse = 1 + Math.sin(state.lastTime * 0.01) * 0.16;
      ctx.save();
      ctx.strokeStyle = "rgba(255,124,124,0.95)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(s.x, s.y - 14, 24 * pulse, 0, Math.PI * 2);
      ctx.stroke();
      ctx.strokeStyle = "rgba(255,223,160,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(s.x - 10, s.y - 24);
      ctx.lineTo(s.x + 10, s.y - 4);
      ctx.moveTo(s.x + 10, s.y - 24);
      ctx.lineTo(s.x - 10, s.y - 4);
      ctx.stroke();
      ctx.fillStyle = "#ffe5c0";
      ctx.font = "bold 11px Trebuchet MS";
      ctx.textAlign = "center";
      ctx.fillText("Revenge", s.x, s.y - 36);
      ctx.restore();
    }

    function drawZoneMarkers() {
      const spacing = BIOME_WIDTH;
      const viewMin = state.camera.x - 300;
      const viewMax = state.camera.x + canvas.width + 300;
      const start = Math.floor(viewMin / spacing) - 1;
      const end = Math.ceil(viewMax / spacing) + 1;
      for (let i = start; i <= end; i++) {
        const wx = i * spacing + spacing * 0.5;
        const sx = wx - state.camera.x;
        const gy = groundY(wx) - state.camera.y;
        const label = biomeAtX(wx).name;
        const band = zoneTierBandAtX(wx);
        ctx.strokeStyle = "#1a1f1f";
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(sx, gy + 1);
        ctx.lineTo(sx, gy - 56);
        ctx.stroke();

        ctx.fillStyle = "rgba(20,38,58,0.9)";
        ctx.strokeStyle = "#111a26";
        ctx.lineWidth = 2;
        ctx.fillRect(sx - 52, gy - 88, 104, 24);
        ctx.strokeRect(sx - 52, gy - 88, 104, 24);
        ctx.fillStyle = "#eaf6ff";
        ctx.font = "11px Trebuchet MS";
        ctx.textAlign = "center";
        ctx.fillText(label, sx, gy - 75);
        ctx.font = "10px Trebuchet MS";
        ctx.fillText(`Tier ${band.min}-${band.max}`, sx, gy - 63);
      }
    }

    function drawGroundTexture() {
      if (!state.gfx.soilPattern) return;
      const top = canvas.height * 0.8;
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = state.gfx.soilPattern;
      ctx.translate(-(state.camera.x * 0.18) % 180, 0);
      ctx.fillRect(-180, top, canvas.width + 360, canvas.height - top);
      ctx.restore();
    }

    function drawHazardZones() {
      for (const z of hazardZones) {
        const sx = z.start - state.camera.x;
        const ex = z.end - state.camera.x;
        if (ex < -40 || sx > canvas.width + 40) continue;
        const x = Math.max(-20, sx);
        const w = Math.min(canvas.width + 20, ex) - x;
        let color = "rgba(255,92,56,0.12)";
        if (z.type === "acid") color = "rgba(132,255,116,0.11)";
        if (z.type === "storm") color = "rgba(138,188,255,0.1)";
        ctx.fillStyle = color;
        ctx.fillRect(x, canvas.height * 0.58, w, canvas.height * 0.42);
        ctx.strokeStyle = color.replace("0.1", "0.4").replace("0.11", "0.4").replace("0.12", "0.4");
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, canvas.height * 0.58);
        ctx.lineTo(x + w, canvas.height * 0.58);
        ctx.stroke();
      }
    }

    function drawResources() {
      const palette = interactionPalette();
      for (const r of state.resources) {
        if (!inView(r.x, r.y, 70)) continue;
        const s = worldToScreen(r.x, r.y);
        const dist = Math.hypot(r.x - state.player.x, r.y - state.player.y);
        const canEat = canConsumeResource(state.player.tier, r);
        const img = foodSpriteCache[r.item];
        if (img && img.complete && img.naturalWidth > 0) {
          const w = r.size * 2.1;
          const h = r.size * 2.1;
          if (r.source === "tree") {
            ctx.fillStyle = "rgba(69,110,77,0.95)";
            ctx.fillRect(s.x - 2, s.y + 6, 4, 16);
          }
          ctx.fillStyle = "rgba(14,24,18,0.22)";
          ctx.beginPath();
          ctx.ellipse(s.x, s.y + r.size * 0.75, r.size * 0.72, r.size * 0.35, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowColor = "rgba(0,0,0,0.25)";
          ctx.shadowBlur = 5;
          ctx.shadowOffsetY = 2;
          ctx.drawImage(img, s.x - w * 0.5, s.y - h * 0.5, w, h);
          ctx.shadowBlur = 0;
          if (dist < VISUALS.resourceHintDistance) {
            ctx.strokeStyle = r.rare ? "rgba(255,225,122,0.97)" : (canEat ? palette.preyRing : palette.blockedRing);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(s.x, s.y, r.size * 1.05, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else {
          if (r.source === "tree") {
            ctx.fillStyle = "rgba(69,110,77,0.95)";
            ctx.fillRect(s.x - 2, s.y + 6, 4, 16);
            ctx.fillStyle = r.nutrition === "plant" ? "#ffcc55" : "#d48368";
            ctx.beginPath();
            ctx.arc(s.x, s.y, r.size, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.fillStyle = r.nutrition === "plant" ? "#93de73" : "#b86464";
            ctx.beginPath();
            ctx.ellipse(s.x, s.y, r.size, r.size * 0.72, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          if (dist < VISUALS.resourceHintDistance) {
            ctx.strokeStyle = r.rare ? "rgba(255,225,122,0.97)" : (canEat ? palette.preyRing : palette.blockedRing);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(s.x, s.y, r.size * 1.05, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }
    }

    function drawBot(b) {
      if (!inView(b.x, b.y)) return;
      const palette = interactionPalette();
      const s = worldToScreen(b.x, b.y);
      const relation = interactionState(state.player.tier, b.tier);
      const dist = Math.hypot(b.x - state.player.x, b.y - state.player.y);
      const theyCanEat = canConsume(b.tier, state.player.tier);
      const ringPulse = 1 + Math.sin(state.lastTime * 0.001 * VISUALS.ringPulseSpeed + b.tier) * 0.08;
      drawEntityVisual(s.x, s.y, b.size * 0.95, b.tier, 1, relation === "blocked" ? 0.18 : 0, !!b.elite);
      if (dist < VISUALS.interactionRingDistance && relation === "prey") {
        ctx.strokeStyle = palette.preyRing;
        ctx.lineWidth = 2.7;
        ctx.beginPath();
        ctx.arc(s.x, s.y, b.size * 0.66 * ringPulse, 0, Math.PI * 2);
        ctx.stroke();
      } else if (dist < VISUALS.interactionRingDistance && theyCanEat) {
        ctx.fillStyle = palette.dangerFill;
        ctx.beginPath();
        ctx.arc(s.x, s.y, b.size * 1.48, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = palette.dangerRing;
        ctx.lineWidth = 2.8;
        ctx.beginPath();
        ctx.arc(s.x, s.y, b.size * 0.72 * ringPulse, 0, Math.PI * 2);
        ctx.stroke();
      } else if (dist < VISUALS.interactionRingDistance && relation === "blocked") {
        ctx.strokeStyle = palette.blockedRing;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(s.x, s.y, b.size * 0.66, 0, Math.PI * 2);
        ctx.stroke();
      }

      if (dist < VISUALS.interactionLabelDistance) {
        ctx.fillStyle = "#0e1f2f";
        ctx.font = "11px Trebuchet MS";
        ctx.textAlign = "center";
        ctx.fillText(`${b.tier}${b.elite ? "" : ""}`, s.x, s.y + 4);
      }
    }

    function drawBoss(b) {
      if (!inView(b.x, b.y, 220)) return;
      const palette = interactionPalette();
      const s = worldToScreen(b.x, b.y);
      const relation = interactionState(state.player.tier, b.tier);
      const hostileGlow = relation === "blocked" ? 0.42 + (b.enraged ? 0.08 : 0) : 0.14;

      if (b.telegraph) {
        const t = b.telegraph;
        const castRatio = clamp(t.timer / Math.max(0.001, t.duration), 0, 1);
        const pulse = 1 + Math.sin(state.lastTime * 0.018 + b.tier) * 0.08;
        if (t.kind === "aoe") {
          const ts = worldToScreen(t.x, t.y);
          const r = t.radius * (0.72 + (1 - castRatio) * 0.3) * pulse;
          ctx.fillStyle = `rgba(255,102,102,${0.08 + (1 - castRatio) * 0.14})`;
          ctx.beginPath();
          ctx.arc(ts.x, ts.y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = `rgba(255,174,122,${0.5 + (1 - castRatio) * 0.45})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(ts.x, ts.y, r, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          const sx = t.x - state.camera.x;
          const sy = t.y - state.camera.y;
          const ex = sx + t.dirX * t.distance;
          const ey = sy + t.dirY * t.distance;
          ctx.strokeStyle = `rgba(255,189,118,${0.34 + (1 - castRatio) * 0.42})`;
          ctx.lineWidth = Math.max(4, t.width * 0.32);
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        }
      }

      drawEntityVisual(s.x, s.y, b.size, b.tier, b.vx >= 0 ? 1 : -1, hostileGlow, true);

      const ringColor = relation === "prey" ? palette.preyRing : palette.dangerRing;
      const ringPulse = 1 + Math.sin(state.lastTime * 0.001 * 5.2 + b.tier) * 0.06;
      ctx.strokeStyle = ringColor;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(s.x, s.y, b.size * 0.72 * ringPulse, 0, Math.PI * 2);
      ctx.stroke();

      ctx.fillStyle = "rgba(14,24,36,0.88)";
      ctx.fillRect(s.x - 74, s.y - b.size * 0.98 - 16, 148, 11);
      ctx.fillStyle = b.accent || "#89ddff";
      ctx.fillRect(s.x - 74, s.y - b.size * 0.98 - 16, 148 * clamp(b.hp / b.maxHp, 0, 1), 11);
      ctx.strokeStyle = "rgba(255,255,255,0.58)";
      ctx.lineWidth = 1.3;
      ctx.strokeRect(s.x - 74, s.y - b.size * 0.98 - 16, 148, 11);

      ctx.fillStyle = "#0e2438";
      ctx.font = "bold 13px Trebuchet MS";
      ctx.textAlign = "center";
      const phaseTag = `P${b.phase || 1}${b.enraged ? "!" : ""}`;
      ctx.fillText(`${b.name} (${phaseTag} T${b.tier})`, s.x, s.y - b.size * 0.98 - 22);
      if (b.telegraph) {
        ctx.fillStyle = "#ffd5a5";
        ctx.font = "bold 11px Trebuchet MS";
        ctx.fillText(`${b.telegraph.name} ${b.telegraph.timer.toFixed(1)}s`, s.x, s.y - b.size * 0.98 - 36);
      }
    }

    function drawPlayer() {
      const p = state.player;
      const s = worldToScreen(p.x, p.y);
      drawEntityVisual(s.x, s.y, p.size, p.tier, p.facing, 0, false);

      if (isMoonTier(p.tier) && p.attackCd > 0) {
        const phase = 1 - p.attackCd / 26;
        const baseStart = p.facing >= 0 ? -1.1 : Math.PI - 1.1;
        const baseEnd = p.facing >= 0 ? 1.1 : Math.PI + 1.1;
        ctx.strokeStyle = `rgba(255,241,166,${0.75 - phase * 0.45})`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(s.x + p.facing * 16, s.y, 44 + phase * 24, baseStart, baseEnd);
        ctx.stroke();
        if (p.tier === 30) {
          const innerStart = p.facing >= 0 ? -1.2 : Math.PI - 1.1;
          const innerEnd = p.facing >= 0 ? 1.1 : Math.PI + 1.2;
          ctx.strokeStyle = `rgba(233,238,248,${0.72 - phase * 0.4})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(s.x + p.facing * 20, s.y - 6, 30 + phase * 14, innerStart, innerEnd);
          ctx.stroke();
        }
      }
      if (isMoonTier(p.tier) && p.moonCombo > 0) {
        ctx.fillStyle = "#d9b557";
        ctx.font = "bold 12px Trebuchet MS";
        ctx.textAlign = "center";
        ctx.fillText(`Combo x${p.moonCombo}`, s.x, s.y - p.size * 0.8 - 20);
      }
      if (p.invulnTimer > 0) {
        const pulse = 1 + Math.sin(state.lastTime * 0.02) * 0.08;
        ctx.strokeStyle = "rgba(173,236,255,0.88)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(s.x, s.y, p.size * 0.7 * pulse, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.fillStyle = "#10263a";
      ctx.font = "12px Trebuchet MS";
      ctx.textAlign = "center";
      ctx.fillText(tiers[p.tier - 1], s.x, s.y - p.size * 0.62 - 6);
    }

    function drawRemotePlayers() {
      const entries = Object.entries(state.net.remotePlayers || {});
      for (const [id, rp] of entries) {
        if (id === state.net.id) continue;
        if (!rp) continue;
        if (!inView(rp.x, rp.y, 120)) continue;
        const s = worldToScreen(rp.x, rp.y);
        drawEntityVisual(s.x, s.y, 34 + (rp.tier || 1) * 1.1, rp.tier || 1, 1, 0.1, false);
        ctx.fillStyle = "#17324a";
        ctx.font = "11px Trebuchet MS";
        ctx.textAlign = "center";
        ctx.fillText(rp.name || "Player", s.x, s.y - 28);
      }
    }

    function drawEntityVisual(x, y, size, tier, facing = 1, hostileGlow = 0, elite = false) {
      const key = spriteKeyForTier(tier);
      const img = spriteCache[key];
      const animT = state.lastTime * 0.001;
      const bob = Math.sin(animT * 5.6 + tier * 0.8) * Math.min(tier === 30 ? 2.2 : 4, size * 0.06);
      const tilt = Math.sin(animT * 4.4 + tier * 0.6) * (tier === 30 ? 0.018 : 0.045);
      if (tier === 30) {
        const pulse = 0.24 + Math.sin(animT * 8.2) * 0.08;
        ctx.fillStyle = `rgba(230,236,245,${pulse})`;
        ctx.beginPath();
        ctx.ellipse(x - facing * size * 0.28, y + bob + size * 0.12, size * 0.7, size * 0.52, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      if (img && img.complete && img.naturalWidth > 0) {
        ctx.save();
        ctx.translate(x, y + bob);
        ctx.rotate(tilt * facing);
        const flutter = (isAirTier(tier) ? Math.sin(animT * 9 + tier) * 0.05 : 0);
        ctx.scale(facing * (1 + flutter * 0.4), 1 - flutter * 0.18);
        const w = tier === 30 ? size * 1.62 : (tier === 29 ? size * 1.5 : size * 1.95);
        const h = tier === 30 ? size * 1.98 : (tier === 29 ? size * 1.78 : size * 1.5);
        ctx.shadowColor = "rgba(0,0,0,0.24)";
        ctx.shadowBlur = 8;
        ctx.shadowOffsetY = 3;
        if (hostileGlow > 0) {
          ctx.fillStyle = `rgba(255,80,80,${0.15 + hostileGlow})`;
          ctx.beginPath();
          ctx.ellipse(0, 0, w * 0.85, h * 0.7, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.fillStyle = "rgba(20,26,38,0.22)";
        ctx.beginPath();
        ctx.ellipse(0, h * 0.28, w * 0.28, h * 0.16, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.drawImage(img, -w * 0.5, -h * 0.52, w, h);
        ctx.shadowBlur = 0;
        if (elite) {
          ctx.strokeStyle = "rgba(255,215,120,0.95)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, size * 0.62, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
        return;
      }
      drawCreature(x, y + bob, size, tier, facing, hostileGlow);
      if (elite) {
        ctx.strokeStyle = "rgba(255,215,120,0.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, size * 0.62, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    function drawCreature(x, y, size, tier, facing = 1, hostileGlow = 0) {
      const profile = tierProfiles[tier - 1] || tierProfiles[0];
      const pulse = Math.sin(Date.now() * 0.012 + tier) * 0.06;
      const wingFlap = Math.sin(Date.now() * 0.024 + tier) * 0.12;
      const bodyW = size * (0.54 + pulse * 0.06);
      const bodyH = size * 0.4;

      ctx.save();
      ctx.translate(x, y);
      ctx.scale(facing, 1);

      if (hostileGlow > 0) {
        ctx.fillStyle = `rgba(255,80,80,${0.15 + hostileGlow})`;
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyW * 1.35, bodyH * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      if (profile.type === "air" || profile.type === "dragon" || profile.type === "moon") {
        ctx.fillStyle = "rgba(255,255,255,0.72)";
        ctx.beginPath();
        ctx.ellipse(-size * 0.34, -size * (0.12 + wingFlap), size * 0.35, size * 0.14, -0.5, 0, Math.PI * 2);
        ctx.fill();
      }
      if (profile.type === "dragon") {
        ctx.fillStyle = "rgba(255,209,133,0.8)";
        ctx.beginPath();
        ctx.ellipse(-size * 0.22, -size * (0.17 - wingFlap), size * 0.3, size * 0.12, 0.5, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = profile.base;
      ctx.beginPath();
      ctx.ellipse(0, 0, bodyW, bodyH, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = profile.accent;
      ctx.beginPath();
      ctx.ellipse(size * 0.3, -size * 0.04, size * 0.22, size * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();

      if (profile.type === "land") {
        ctx.strokeStyle = profile.accent;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-size * 0.2, bodyH * 0.6);
        ctx.lineTo(-size * 0.2, bodyH * 1.0);
        ctx.moveTo(size * 0.05, bodyH * 0.6);
        ctx.lineTo(size * 0.05, bodyH * 1.0);
        ctx.stroke();
      }

      if (profile.type === "moon") {
        ctx.strokeStyle = "#d3b54f";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(size * 0.68, -2, size * 0.25, -1.2, 1.2);
        ctx.stroke();
      }

      ctx.fillStyle = profile.eye;
      ctx.beginPath();
      ctx.arc(size * 0.35, -size * 0.08, size * 0.05, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function nearestBotByRelation(relationWanted) {
      const p = state.player;
      let best = null;
      let bestDist = Number.POSITIVE_INFINITY;
      for (const b of state.bots) {
        const relation = interactionState(p.tier, b.tier);
        const theyEat = canConsume(b.tier, p.tier);
        const ok = relationWanted === "prey" ? relation === "prey" : theyEat;
        if (!ok) continue;
        const d = Math.hypot(b.x - p.x, b.y - p.y);
        if (d < bestDist) {
          bestDist = d;
          best = b;
        }
      }
      return best ? { bot: best, dist: bestDist } : null;
    }

    function drawDirectionPointer(target, color, label) {
      if (!target) return;
      const textScale = state.settings.textScale || 1;
      const s = worldToScreen(target.x, target.y);
      if (s.x >= 20 && s.x <= canvas.width - 20 && s.y >= 20 && s.y <= canvas.height - 20) return;
      const cx = clamp(s.x, 26, canvas.width - 26);
      const cy = clamp(s.y, 26, canvas.height - 26);
      const ang = Math.atan2(s.y - canvas.height * 0.5, s.x - canvas.width * 0.5);
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ang);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(-7, -6);
      ctx.lineTo(-7, 6);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      ctx.fillStyle = color;
      ctx.font = `bold ${Math.floor(11 * textScale)}px Trebuchet MS`;
      ctx.textAlign = "center";
      ctx.fillText(label, cx, cy - 10);
    }

    function hudLeaderboardRows(limit = 10) {
      const rows = [];
      if (state.net.leaderboard.length) {
        for (const item of state.net.leaderboard) {
          if (!item) continue;
          rows.push({
            name: (item.name || "Player").trim() || "Player",
            score: Math.max(0, Math.floor(item.score || 0))
          });
        }
      }
      if (!rows.length) {
        rows.push({
          name: (ui.playerName.value || "You").trim() || "You",
          score: Math.max(0, Math.floor(state.score || 0))
        });
      }
      rows.sort((a, b) => b.score - a.score);
      return rows.slice(0, limit);
    }

    function drawHudSpriteChip(tier, x, y, size, ring = "#56e38d") {
      ctx.fillStyle = "rgba(5,18,30,0.72)";
      ctx.beginPath();
      ctx.arc(x, y, size * 0.58, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = ring;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(x, y, size * 0.62, 0, Math.PI * 2);
      ctx.stroke();
      const key = spriteKeyForTier(tier);
      const img = spriteCache[key];
      if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x - size * 0.48, y - size * 0.44, size * 0.96, size * 0.9);
      } else {
        drawCreature(x, y, size * 0.78, tier, 1, 0);
      }
    }

    function drawArenaHud() {
      const p = state.player;
      const sv = state.survival;
      const perks = tierPerkProfile(p.tier);
      const objective = state.objective;
      const palette = interactionPalette();
      const uiScale = clamp(canvas.width / 1900, 0.54, 1) * (state.settings.textScale || 1);
      const margin = 14;
      const leftW = Math.min(312, Math.max(190, canvas.width * 0.18));
      const rightW = Math.min(200, Math.max(130, canvas.width * 0.1));
      const hudX = leftW + 16;
      const hudY = 12;
      const hudW = Math.max(380, canvas.width - hudX - rightW - 18);
      const hudH = 138;
      const xpRatio = clamp(p.xp / Math.max(1, p.xpToNext), 0, 1);
      const enRatio = clamp(sv.energy / 100, 0, 1);
      const hyRatio = clamp(sv.hydration / 100, 0, 1);
      const oxRatio = clamp(sv.oxygen / 100, 0, 1);
      const nextTier = Math.min(30, p.tier + 1);
      const ping = state.net.connected ? 20 + (state.net.onlineCount % 8) * 3 : 0;
      const fps = Math.max(12, Math.min(165, Math.round(state.hudFps || 60)));
      const edible = state.bots
        .map((b) => ({ b, d: Math.hypot(b.x - p.x, b.y - p.y) }))
        .filter((x) => canConsume(p.tier, x.b.tier))
        .sort((a, b) => a.d - b.d)
        .slice(0, 7);

      const titleStroke = "rgba(8,12,18,0.9)";
      const leaders = hudLeaderboardRows(8);
      ctx.font = `bold ${Math.floor(24 * uiScale)}px Trebuchet MS`;
      ctx.textAlign = "left";
      ctx.lineWidth = 5 * uiScale;
      ctx.strokeStyle = titleStroke;
      ctx.strokeText("The Best Players:", margin + 4, 36);
      ctx.fillStyle = "#f2f6ff";
      ctx.fillText("The Best Players:", margin + 4, 36);

      let ly = 64;
      for (let i = 0; i < leaders.length; i++) {
        const row = leaders[i];
        const rank = i + 1;
        const star = rank <= 3 ? "" : `${rank}.`;
        const name = row.name.length > 16 ? `${row.name.slice(0, 16)}` : row.name;
        ctx.font = `bold ${Math.floor(18 * uiScale)}px Trebuchet MS`;
        ctx.strokeStyle = titleStroke;
        ctx.strokeText(star, margin, ly);
        ctx.fillStyle = rank <= 3 ? "#f8d777" : "#78c4ff";
        ctx.fillText(star, margin, ly);

        ctx.font = `bold ${Math.floor(20 * uiScale)}px Trebuchet MS`;
        ctx.strokeStyle = titleStroke;
        ctx.strokeText(name, margin + 34, ly);
        ctx.fillStyle = "#ebf3ff";
        ctx.fillText(name, margin + 34, ly);

        ctx.textAlign = "right";
        ctx.strokeStyle = titleStroke;
        ctx.strokeText(`${row.score}`, leftW - 6, ly);
        ctx.fillStyle = "#ffb53f";
        ctx.fillText(`${row.score}`, leftW - 6, ly);
        ctx.textAlign = "left";
        ly += 24 * uiScale;
      }

      ctx.fillStyle = "rgba(10,24,40,0.74)";
      ctx.fillRect(hudX, hudY, hudW, hudH);
      ctx.strokeStyle = "rgba(188,220,248,0.48)";
      ctx.lineWidth = 2;
      ctx.strokeRect(hudX, hudY, hudW, hudH);

      const barX = hudX + 12;
      const barW = hudW - 24;
      const rowTop = hudY + 12;
      ctx.font = `bold ${Math.floor(15 * uiScale)}px Trebuchet MS`;
      ctx.fillStyle = "#f1f7ff";
      ctx.textAlign = "left";
      ctx.fillText(`Current: ${tiers[p.tier - 1]}`, barX, rowTop - 2);
      ctx.textAlign = "center";
      ctx.fillText(`${Math.floor(p.xp)} / ${p.xpToNext}`, hudX + hudW * 0.5, rowTop - 2);
      ctx.textAlign = "right";
      ctx.fillText(`Next: ${nextTier === p.tier ? "MAX" : tiers[nextTier - 1]}`, barX + barW, rowTop - 2);

      ctx.fillStyle = "rgba(225,236,247,0.34)";
      ctx.fillRect(barX, rowTop + 6, barW, 11);
      ctx.fillStyle = "#8ac8f7";
      ctx.fillRect(barX, rowTop + 6, barW * xpRatio, 11);

      ctx.fillStyle = "rgba(225,236,247,0.34)";
      ctx.fillRect(barX, rowTop + 24, barW, 10);
      ctx.fillStyle = "#2f8fd9";
      ctx.fillRect(barX, rowTop + 24, barW * oxRatio, 10);

      ctx.fillStyle = "rgba(225,236,247,0.34)";
      ctx.fillRect(barX, rowTop + 41, barW, 10);
      ctx.fillStyle = "#71d8f2";
      ctx.fillRect(barX, rowTop + 41, barW * hyRatio, 10);

      ctx.font = `bold ${Math.floor(13 * uiScale)}px Trebuchet MS`;
      ctx.fillStyle = "#eaf6ff";
      ctx.textAlign = "center";
      ctx.fillText("oxygen", hudX + hudW * 0.5, rowTop + 32);
      ctx.fillText(`water (HY ${Math.floor(sv.hydration)})`, hudX + hudW * 0.5, rowTop + 49);

      ctx.font = `bold ${Math.floor(15 * uiScale)}px Trebuchet MS`;
      ctx.textAlign = "left";
      ctx.fillText("You eat:", barX, rowTop + 71);
      let cx = barX + 88;
      const chipY = rowTop + 69;
      if (edible.length) {
        for (let i = 0; i < edible.length; i++) {
          drawHudSpriteChip(edible[i].b.tier, cx, chipY, 34 * uiScale, palette.hudChipRing);
          cx += 42;
          if (cx > barX + barW - 24) break;
        }
      } else {
        ctx.font = `bold ${Math.floor(13 * uiScale)}px Trebuchet MS`;
        ctx.fillStyle = "#f3b2b2";
        ctx.fillText("None nearby", barX + 88, rowTop + 71);
      }

      if (objective) {
        const ratio = clamp(objective.progress / Math.max(1, objective.target), 0, 1);
        const objectiveY = rowTop + 82;
        ctx.textAlign = "left";
        ctx.font = `bold ${Math.floor(12 * uiScale)}px Trebuchet MS`;
        ctx.fillStyle = "#d5ecff";
        ctx.fillText(`Goal: ${objective.label} ${objective.progress}/${objective.target}`, barX, objectiveY);
        ctx.textAlign = "right";
        ctx.fillStyle = objective.timeLeft < 20 ? "#ffb8b8" : "#d5ecff";
        ctx.fillText(`${Math.ceil(objective.timeLeft)}s`, barX + barW, objectiveY);
        ctx.fillStyle = "rgba(225,236,247,0.28)";
        ctx.fillRect(barX, objectiveY + 6, barW, 7);
        ctx.fillStyle = "#95e2ff";
        ctx.fillRect(barX, objectiveY + 6, barW * ratio, 7);
      }

      ctx.font = `bold ${Math.floor(18 * uiScale)}px Trebuchet MS`;
      ctx.textAlign = "right";
      ctx.lineWidth = 4 * uiScale;
      ctx.strokeStyle = titleStroke;
      ctx.strokeText("North America 1", canvas.width - margin, 28);
      ctx.fillStyle = "#f4fbff";
      ctx.fillText("North America 1", canvas.width - margin, 28);
      ctx.font = `bold ${Math.floor(16 * uiScale)}px Trebuchet MS`;
      ctx.strokeText(state.net.connected ? `${ping} ms | ${fps} fps` : "Offline", canvas.width - margin, 52);
      ctx.fillStyle = state.net.connected ? "#4bf06b" : "#f8a7a7";
      ctx.fillText(state.net.connected ? `${ping} ms | ${fps} fps` : "Offline", canvas.width - margin, 52);

      const preyInfo = nearestBotByRelation("prey");
      const dangerInfo = nearestBotByRelation("danger");
      drawDirectionPointer(preyInfo?.bot, palette.ediblePointer, preyInfo ? `PREY ${Math.floor(preyInfo.dist)}` : "PREY");
      drawDirectionPointer(dangerInfo?.bot, palette.dangerPointer, dangerInfo ? `DANGER ${Math.floor(dangerInfo.dist)}` : "DANGER");

      if (state.match.spawnShield > 0) {
        ctx.font = `bold ${Math.floor(13 * uiScale)}px Trebuchet MS`;
        ctx.textAlign = "center";
        ctx.fillStyle = "#9ee3ff";
        ctx.fillText(`Spawn Shield ${state.match.spawnShield.toFixed(1)}s`, hudX + hudW * 0.5, hudY + hudH - 8);
      }
      if (state.match.streak > 0) {
        ctx.font = `bold ${Math.floor(13 * uiScale)}px Trebuchet MS`;
        ctx.textAlign = "right";
        ctx.fillStyle = "#ffe186";
        ctx.fillText(`Streak ${state.match.streak}`, barX + barW, hudY + hudH - 8);
      }
      ctx.font = `bold ${Math.floor(12 * uiScale)}px Trebuchet MS`;
      ctx.textAlign = "left";
      ctx.fillStyle = enRatio < 0.25 ? "#ffb9a1" : "#ffe396";
      ctx.fillText(`EN ${Math.floor(sv.energy)}`, barX, hudY + hudH - 8);
      const aeroCost = upgradeCost("aero");
      const guardCost = upgradeCost("guard");
      const moonCost = upgradeCost("moon");
      ctx.font = `bold ${Math.floor(11 * uiScale)}px Trebuchet MS`;
      ctx.textAlign = "left";
      ctx.fillStyle = "#98ecff";
      ctx.fillText(`Relic ${state.loot.relics} | Shard ${state.loot.shards} | Core ${state.loot.cores}`, barX, hudY + hudH - 22);
      ctx.textAlign = "right";
      ctx.fillStyle = "#c7edff";
      ctx.fillText(`Perks SPD ${Math.round((perks.speedBoost - 1) * 100)}% CD -${Math.round((1 - perks.cooldownMult) * 100)}%`, barX + barW, hudY + hudH - 8);
      ctx.font = `bold ${Math.floor(11 * uiScale)}px Trebuchet MS`;
      ctx.fillStyle = "#bfe3ff";
      ctx.fillText(`Buy: 1 Aero ${aeroCost ?? "MAX"} | 2 Guard ${guardCost ?? "MAX"} | 3 Moon ${moonCost ?? "MAX"}`, barX + barW, hudY + hudH - 22);
      if (p.invulnTimer > 0) {
        ctx.textAlign = "center";
        ctx.fillStyle = "#9ee3ff";
        ctx.fillText(`Guard ${p.invulnTimer.toFixed(1)}s`, hudX + hudW * 0.5, hudY + hudH - 8);
      }
    }

    function drawKillfeed() {
      const items = state.match.killfeed;
      if (!items.length) return;
      const textScale = state.settings.textScale || 1;
      const boxW = 270;
      const x = canvas.width - boxW - 14;
      let y = 154;
      ctx.fillStyle = "rgba(8,16,28,0.45)";
      ctx.fillRect(x, y - 18, boxW, 18 + items.length * 14);
      ctx.strokeStyle = "rgba(198,221,246,0.2)";
      ctx.strokeRect(x, y - 18, boxW, 18 + items.length * 14);
      ctx.fillStyle = "#d7ecff";
      ctx.font = `bold ${Math.floor(12 * textScale)}px Trebuchet MS`;
      ctx.textAlign = "left";
      ctx.fillText("Killfeed", x + 8, y - 4);
      for (const item of items) {
        ctx.fillStyle = item.color || "#dbeeff";
        ctx.font = `normal ${Math.floor(10 * textScale)}px Trebuchet MS`;
        ctx.fillText(item.text, x + 8, y + 11);
        y += 14;
      }
    }

    function drawRespawnOverlay() {
      if (state.match.respawnTimer <= 0) return;
      const textScale = state.settings.textScale || 1;
      ctx.fillStyle = "rgba(7,10,16,0.55)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#f1f5ff";
      ctx.font = `bold ${Math.floor(34 * textScale)}px Trebuchet MS`;
      ctx.textAlign = "center";
      ctx.fillText(`Respawn in ${Math.ceil(state.match.respawnTimer)}`, canvas.width * 0.5, canvas.height * 0.45);
      ctx.font = `${Math.floor(16 * textScale)}px Trebuchet MS`;
      ctx.fillStyle = "#c6d8ee";
      ctx.fillText(`Cause: ${state.match.deathReason || "unknown"}`, canvas.width * 0.5, canvas.height * 0.51);
      ctx.fillText(`Lost tier: ${state.death.tier} | Lost streak: ${state.death.streakLost}`, canvas.width * 0.5, canvas.height * 0.56);
      if (state.death.revengeActive) {
        ctx.fillStyle = "#ffd8b4";
        ctx.fillText(`Revenge marker active (+${state.death.revengeXp} XP)`, canvas.width * 0.5, canvas.height * 0.61);
      }
    }

    function drawMiniMap() {
      const mapW = 190;
      const mapH = 100;
      const x = canvas.width - mapW - 14;
      const y = 174;
      ctx.fillStyle = "rgba(10,18,34,0.62)";
      ctx.fillRect(x, y, mapW, mapH);
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.strokeRect(x, y, mapW, mapH);

      const px = x + (state.player.x / WORLD.width) * mapW;
      const py = y + (state.player.y / WORLD.height) * mapH;
      ctx.fillStyle = "#ffe47a";
      ctx.beginPath();
      ctx.arc(px, py, 4, 0, Math.PI * 2);
      ctx.fill();

      const tx = x + (TUNNEL.entranceX / WORLD.width) * mapW;
      const ty = y + (groundY(TUNNEL.entranceX) / WORLD.height) * mapH;
      ctx.fillStyle = "#7feaff";
      ctx.fillRect(tx - 2, ty - 2, 4, 4);

      for (const b of state.bosses) {
        const bx = x + (b.x / WORLD.width) * mapW;
        const by = y + (b.y / WORLD.height) * mapH;
        ctx.fillStyle = b.accent || "#ff8f8f";
        ctx.beginPath();
        ctx.arc(bx, by, 2.8, 0, Math.PI * 2);
        ctx.fill();
      }

      for (const lm of landmarkDefs) {
        const lx = x + (lm.x / WORLD.width) * mapW;
        ctx.fillStyle = "rgba(170,225,255,0.95)";
        ctx.fillRect(lx - 1.5, y + 5, 3, 3);
      }
      if (state.death.revengeActive && state.death.lastX != null) {
        const rx = x + (state.death.lastX / WORLD.width) * mapW;
        const ry = y + (state.death.lastY / WORLD.height) * mapH;
        ctx.fillStyle = "rgba(255,128,128,0.95)";
        ctx.beginPath();
        ctx.arc(rx, ry, 2.2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawCombatTexts() {
      for (const t of state.combatTexts) {
        if (!inView(t.x, t.y, 80)) continue;
        const s = worldToScreen(t.x, t.y);
        const alpha = clamp(t.life / t.maxLife, 0, 1);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = `bold ${t.size}px Trebuchet MS`;
        ctx.textAlign = "center";
        ctx.strokeStyle = "rgba(12,18,28,0.78)";
        ctx.lineWidth = 3;
        ctx.strokeText(t.text, s.x, s.y);
        ctx.fillStyle = t.color;
        ctx.fillText(t.text, s.x, s.y);
        ctx.restore();
      }
    }

    function renderScene() {
      const shake = state.fx.shakeTime > 0
        ? {
            x: (Math.random() - 0.5) * state.fx.shakePower,
            y: (Math.random() - 0.5) * state.fx.shakePower * 0.7
          }
        : { x: 0, y: 0 };
      ctx.save();
      if (shake.x || shake.y) ctx.translate(shake.x, shake.y);
      drawWorld();
      drawResources();
      state.bots.forEach(drawBot);
      state.bosses.forEach(drawBoss);
      drawRemotePlayers();
      drawPlayer();
      drawCombatTexts();
      ctx.restore();

      if (state.fx.hitFlash > 0) {
        ctx.fillStyle = `rgba(255,236,210,${Math.min(0.16, state.fx.hitFlash)})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      drawArenaHud();
      drawKillfeed();
      drawRespawnOverlay();
      if (state.gameStarted && state.showMiniMap) drawMiniMap();
    }

    function startGame() {
      if (state.gameStarted) return;
      resetRunState(true);
      resizeCanvasToDisplaySize();
      state.currentBiome = biomeAtX(state.player.x).name;
      setBiomeMission(state.currentBiome);
      state.gameStarted = true;
      state.lastTime = 0;
      state.loop.accumulator = 0;
      state.match.spawnShield = 4;
      state.match.respawnTimer = 0;
      state.match.deathReason = "";
      state.match.killfeed.length = 0;
      setNextObjective("start");
      pushKillfeed("Match started", "#b7e6ff");
      ui.startScreen.classList.add("hidden");
      ui.appRoot.classList.remove("prelaunch");
      ui.appRoot.classList.add("in-game");
      ui.playBtn.textContent = "LIVE";
      ui.playBtn.disabled = true;
      ui.playBtn.style.opacity = "0.7";
      if (!state.net.socket || state.net.socket.readyState > 1) {
        connectMultiplayer();
      }
      playSfx("start");
      showToast("Joined arena");
      requestAnimationFrame(gameLoop);
    }

    function stepSimulation(dt) {
      state.abilities.q.cd = Math.max(0, state.abilities.q.cd - dt);
      state.abilities.e.cd = Math.max(0, state.abilities.e.cd - dt);
      state.abilities.f.cd = Math.max(0, state.abilities.f.cd - dt);
      updateWorldSystems(dt);

      if (state.fx.hitStop > 0) {
        state.fx.hitStop = Math.max(0, state.fx.hitStop - dt);
        updateCombatTexts(dt);
        sendNetworkState(dt * 0.25);
        return;
      }

      if (state.match.respawnTimer > 0) {
        state.match.respawnTimer = Math.max(0, state.match.respawnTimer - dt);
        if (state.match.respawnTimer <= 0) performRespawn();
        return;
      }

      updatePlayer(dt);
      updateSurvival(dt);
      updateResources();
      updateBots(dt);
      updateBosses(dt);
      updateCombatTexts(dt);
      sendNetworkState(dt);
      handleLevelUp();
      syncAccountProgressFromRun();
    }

    function gameLoop(ts = 0) {
      if (!state.gameStarted) return;
      const dtRaw = state.lastTime ? (ts - state.lastTime) / 1000 : state.loop.fixedDt;
      const dt = clamp(dtRaw, 1 / 240, 0.1);
      state.lastTime = ts;
      state.hudFps = state.hudFps * 0.9 + (1 / Math.max(dt, 1 / 240)) * 0.1;
      updateAutoPerformance(dt);
      state.loop.accumulator = Math.min(
        state.loop.accumulator + dt,
        state.loop.fixedDt * state.loop.maxSubSteps
      );

      let steps = 0;
      while (state.loop.accumulator >= state.loop.fixedDt && steps < state.loop.maxSubSteps) {
        stepSimulation(state.loop.fixedDt);
        state.loop.accumulator -= state.loop.fixedDt;
        steps += 1;
      }
      if (steps >= state.loop.maxSubSteps) {
        state.loop.accumulator = 0;
      }

      updateHud();
      renderScene();
      requestAnimationFrame(gameLoop);
    }

    async function bootstrap() {
      loadLocalSettings();
      if (!AUDIO_ENABLED) disableAudioUi();
      initSprites();
      initGraphicsAssets();
      resizeCanvasToDisplaySize();
      ui.appRoot.classList.add("prelaunch");
      ui.appRoot.classList.remove("in-game");
      updatePanelToggleLabel();
      syncSettingsUi();
      applySettingsFromUi(false);
      resetRunState(true);
      state.currentBiome = biomeAtX(state.player.x).name;
      setBiomeMission(state.currentBiome);
      syncCamera(1 / 60);
      await loadAuthConfig();
      updateAuthUi();
      updateProgressHint();
      waitForGoogleSdk();
      await restoreSession();
      updateHud();
      renderScene();
      showToast("Preview mode: click Play to join");
      setInterval(() => {
        if (state.gameStarted && state.settings.autoSave) saveProgress();
      }, 15000);
    }

    let resizeFrame = 0;
    window.addEventListener("resize", () => {
      if (resizeFrame) cancelAnimationFrame(resizeFrame);
      resizeFrame = requestAnimationFrame(() => {
        resizeFrame = 0;
        const changed = resizeCanvasToDisplaySize();
        if (changed) {
          syncCamera(1 / 60);
          if (!state.gameStarted) {
            updateHud();
            renderScene();
          }
        }
      });
    });

    function updatePanelToggleLabel() {
      ui.togglePanelBtn.textContent = ui.controlPanel.classList.contains("collapsed")
        ? "Show Panel (Tab)"
        : "Hide Panel (Tab)";
    }

    function openSettingsPanel() {
      ui.controlPanel.classList.remove("collapsed");
      updatePanelToggleLabel();
      const top = Math.max(0, (ui.settingsSection?.offsetTop || 0) - 10);
      ui.controlPanel.scrollTo({ top, behavior: "smooth" });
    }

    window.addEventListener("keydown", (e) => {
      unlockAudio();
      const code = String(e.code || "");
      if (["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Tab"].includes(code)) {
        e.preventDefault();
      }

      if (state.controlCapture) {
        e.preventDefault();
        if (code === "Escape") {
          const label = CONTROL_LABELS[state.controlCapture] || "Control";
          state.controlCapture = null;
          renderControlBindingsUi();
          showToast(`Bind cancelled (${label})`);
          return;
        }
        setControlBinding(state.controlCapture, code);
        state.controlCapture = null;
        renderControlBindingsUi();
        return;
      }

      if (code === "Tab") {
        ui.controlPanel.classList.toggle("collapsed");
        updatePanelToggleLabel();
      }
      if (!state.gameStarted) {
        if (code === "Enter" || code === "Space") {
          startGame();
        }
        return;
      }

      state.keys[code] = true;
      if (!e.repeat && eventMatchesAction(e, "minimap")) {
        state.showMiniMap = !state.showMiniMap;
        ui.minimapToggle.checked = state.showMiniMap;
        applySettingsFromUi(true, true);
        showToast(state.showMiniMap ? "Minimap On" : "Minimap Off");
      }
      if (!e.repeat && (eventMatchesAction(e, "jump") || eventMatchesAction(e, "moveUp"))) {
        state.input.jumpQueued = true;
      }
      if (!e.repeat && eventMatchesAction(e, "abilityQ")) castDashBite();
      if (!e.repeat && eventMatchesAction(e, "abilityE")) castSonicCry();
      if (!e.repeat && eventMatchesAction(e, "abilityF")) castRegen();
      if (!e.repeat && eventMatchesAction(e, "attack")) attackMoonBlade();
      if (!e.repeat && eventMatchesAction(e, "respawn")) testerRespawn();
      if (!e.repeat && code === "Digit1") tryBuyLootUpgrade("aero");
      if (!e.repeat && code === "Digit2") tryBuyLootUpgrade("guard");
      if (!e.repeat && code === "Digit3") tryBuyLootUpgrade("moon");
    });

    window.addEventListener("keyup", (e) => {
      const code = String(e.code || "");
      state.keys[code] = false;
    });

    window.addEventListener("blur", () => {
      state.keys = {};
      state.input.jumpQueued = false;
    });

    window.addEventListener("pointerdown", unlockAudio, { passive: true });

    ui.signupBtn.addEventListener("click", async () => {
      const name = ui.playerName.value.trim();
      const email = ui.playerEmail.value.trim();
      if (!name || !email.includes("@")) {
        showToast("Enter valid name + email");
        return;
      }
      const signupData = await apiFetch("/api/signup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, email })
      });
      if (!signupData || !signupData.ok || !signupData.user) {
        showToast("Signup failed. Please try again.");
        return;
      }
      setLoggedInUser({
        name: signupData.user.name || name,
        email: signupData.user.email || email,
        provider: signupData.user.authProvider || "local"
      });
      await loadProgressAndLeaderboard();
      if (state.gameStarted && (!state.net.socket || state.net.socket.readyState > 1)) {
        connectMultiplayer();
      }
      await saveProgress();
      showToast("Account created");
    });

    ui.googleBtn.addEventListener("click", async () => {
      const ready = await waitForGoogleSdk(10000);
      if (ready) {
        window.google.accounts.id.prompt((notification) => {
          if (!notification) return;
          if (notification.isNotDisplayed?.() || notification.isSkippedMoment?.()) {
            ui.googleHint.textContent = "Google popup was blocked/skipped. Use the Google button below or allow popups.";
          }
        });
      } else {
        showToast("Google SDK blocked or not configured");
      }
    });

    ui.playBtn.addEventListener("click", startGame);
    ui.startBtn.addEventListener("click", startGame);
    ui.startSettingsBtn.addEventListener("click", () => {
      openSettingsPanel();
      showToast("Settings opened");
    });
    ui.presetLowBtn.addEventListener("click", () => {
      applyPreset("low");
      showToast("Preset: Low");
    });
    ui.presetBalancedBtn.addEventListener("click", () => {
      applyPreset("balanced");
      showToast("Preset: Balanced");
    });
    ui.presetUltraBtn.addEventListener("click", () => {
      applyPreset("ultra");
      showToast("Preset: Ultra");
    });
    ui.exportSettingsBtn.addEventListener("click", exportSettingsToFile);
    ui.importSettingsBtn.addEventListener("click", () => {
      ui.importSettingsFile.value = "";
      ui.importSettingsFile.click();
    });
    ui.importSettingsFile.addEventListener("change", async (e) => {
      const file = e.target?.files?.[0];
      await importSettingsFromFile(file || null);
    });
    ui.qualitySelect.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(`Graphics: ${state.quality}`);
    });
    ui.autoPerfToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.settings.autoPerformance ? "Auto Performance On" : "Auto Performance Off");
    });
    ui.reduceMotionToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.settings.reduceMotion ? "Reduced Motion On" : "Reduced Motion Off");
    });
    ui.minimapToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.showMiniMap ? "Minimap On" : "Minimap Off");
    });
    ui.advancedHudToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.settings.advancedHud ? "Detailed HUD On" : "Detailed HUD Off");
    });
    ui.autosaveToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.settings.autoSave ? "Auto Save On" : "Auto Save Off");
    });
    ui.textScaleSelect.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(`Text Size: ${Math.round((state.settings.textScale || 1) * 100)}%`);
    });
    ui.highContrastToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.settings.highContrast ? "High Contrast On" : "High Contrast Off");
    });
    ui.colorblindToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.settings.colorblindSafe ? "Colorblind Rings On" : "Colorblind Rings Off");
    });
    ui.muteMasterToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.audioSettings.muteMaster ? "Master Muted" : "Master Unmuted");
    });
    ui.muteMusicToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.audioSettings.muteMusic ? "Music Muted" : "Music Unmuted");
    });
    ui.muteSfxToggle.addEventListener("change", () => {
      applySettingsFromUi(true, true);
      showToast(state.audioSettings.muteSfx ? "SFX Muted" : "SFX Unmuted");
    });
    ui.masterVolumeSlider.addEventListener("input", () => applySettingsFromUi(true, false));
    ui.musicVolumeSlider.addEventListener("input", () => applySettingsFromUi(true, false));
    ui.sfxVolumeSlider.addEventListener("input", () => applySettingsFromUi(true, false));
    ui.masterVolumeSlider.addEventListener("change", () => applySettingsFromUi(true, true));
    ui.musicVolumeSlider.addEventListener("change", () => applySettingsFromUi(true, true));
    ui.sfxVolumeSlider.addEventListener("change", () => applySettingsFromUi(true, true));
    for (const btn of ui.bindButtons) {
      btn.addEventListener("click", () => {
        const action = btn.dataset.bind;
        if (!action) return;
        state.controlCapture = action;
        renderControlBindingsUi();
        showToast(`Press a key for ${CONTROL_LABELS[action] || "action"}`);
      });
    }
    ui.resetControlsBtn.addEventListener("click", () => {
      const ok = window.confirm("Reset all key bindings to default?");
      if (!ok) return;
      resetControlBindingsToDefault(true);
      showToast("Controls reset");
    });
    ui.resetSettingsBtn.addEventListener("click", () => {
      const confirmReset = window.confirm("Reset all settings (including controls/audio) to default?");
      if (!confirmReset) return;
      const before = snapshotCurrentSettings();
      resetSettingsToDefault(true);
      showToast("Settings reset", {
        actionLabel: "Undo",
        duration: 5000,
        onAction: () => {
          applySettingsSnapshot(before, true);
          showToast("Settings restored");
        }
      });
    });

    ui.togglePanelBtn.addEventListener("click", () => {
      ui.controlPanel.classList.toggle("collapsed");
      updatePanelToggleLabel();
    });

    ui.subBtn.addEventListener("click", () => {
      if (!state.signedUp) {
        showToast("Sign up first");
        return;
      }
      state.subscribed = !state.subscribed;
      ui.subBtn.textContent = state.subscribed
        ? "Subscription Active (+60%)"
        : "Activate Subscription Boost (+60%)";
      saveProgress();
      showToast(state.subscribed ? "Boost enabled" : "Boost disabled");
    });

    ui.logoutBtn.addEventListener("click", async () => {
      await apiFetch("/api/logout", { method: "POST" });
      setLoggedOutUser();
      showToast("Logged out");
    });

    bootstrap();
  </script>
</body>
</html>
